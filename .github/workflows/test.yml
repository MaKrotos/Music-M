name: –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞ Music M test

on:
  workflow_dispatch:
    inputs:
      namevers:
        description: "–ù–∞–∑–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "ü§ñ –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞"
      descr:
        description: "–û–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "‚ùå –û–ø–∏—Å–∞–Ω–∏–µ —Å–±–æ—Ä–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
      release:
        description: "–í—ã–∫–∏–Ω—É—Ç—å –≤ —Ä–µ–ª–∏–∑?"
        required: true
        default: false
        type: boolean
      prerelease:
        description: "–ü—Ä–µ—Ä–µ–ª–∏–∑?"
        required: true
        default: true
        type: boolean

  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    strategy:
      matrix:
        configuration: [Unpacked]
        platform: [x64]

    runs-on:
      windows-latest # –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ä–∞–Ω–Ω–µ—Ä–æ–≤
      # —Å–º. https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    env:
      Solution_Name: "VK UI3"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          node-version: 16
          fetch-depth: 0

      # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤ base64 pfx –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º Signing_Certificate
      - name: Decode the pfx
        run: |
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
      - name: –û–±–Ω–æ–≤–∏—Ç—å TOKEN_STAT_SLY
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $content = Get-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs"
          $updatedContent = $content -replace 'Environment.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)', '"${{ secrets.TOKEN_STAT_SLY }}"'
          Set-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs" -Value $updatedContent
          Write-Output $updatedContent
      - name: Display disk tree
        run: |
          Get-ChildItem -Recurse | Sort-Object Length -Descending
      # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å .NET Core
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      # –î–æ–±–∞–≤–∏—Ç—å MSBuild –≤ PATH: https://github.com/microsoft/setup-msbuild
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2

      # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–∞–ø–∫–∏ obj RuntimeIdentifiers
      - name: Restore the application
        run: msbuild $env:Solution_Name /t:Restore /p:Configuration=$env:Configuration
        env:
          Configuration: ${{ matrix.configuration }}

      - name: Print working directory
        run: |
          Write-Host "Current working directory: $(Get-Location)"

      # –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–∫–µ—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –ø—É—Ç–µ–º —Å–±–æ—Ä–∫–∏ –∏ —É–ø–∞–∫–æ–≤–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞
      - name: Create the app package
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          $platforms = @{
            "x64"   = @{ PlatformTarget = "x64";   RuntimeId = "win-x64" }
            "x86"   = @{ PlatformTarget = "x86";   RuntimeId = "win-x86" }
            "ARM64" = @{ PlatformTarget = "ARM64"; RuntimeId = "win-arm64" }
          }
          
          foreach ($platform in $platforms.Keys) {
            Write-Host "Building for platform: $platform"
            
            msbuild $env:Solution_Name `
              /p:Configuration=$env:Configuration `
              /p:Platform=$platform `
              /p:PlatformTarget=$($platforms[$platform].PlatformTarget) `
              /p:RuntimeIdentifier=$($platforms[$platform].RuntimeId) `
              /p:UapAppxPackageBuildMode=$env:Appx_Package_Build_Mode `
              /p:AppxBundle=$env:Appx_Bundle `
              /p:PackageCertificateKeyFile="$certificatePath" `
              /p:PackageCertificatePassword="${{ secrets.PFX_PASSWORD }}" `
              /p:AppxPackageDir="$env:Appx_Package_Dir" `
              /p:GenerateAppxPackageOnBuild=true `
              /p:TOKEN_STAT_SLY="${{ secrets.TOKEN_STAT_SLY }}"
          }
        env:
          Appx_Bundle: Never
          Appx_Package_Build_Mode: SideloadOnly
          Appx_Package_Dir: Packages\
          Configuration: ${{ matrix.configuration }}

      # –£–¥–∞–ª–∏—Ç—å pfx
      - name: Remove the pfx
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          Remove-Item -path "$certificatePath"
      # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å .cer —Ñ–∞–π–ª
      - name: Rename the .cer file
        run: |
          Get-ChildItem -Path "${{ env.Solution_Name }}\\Packages" -Filter *.cer -Recurse -Depth 1 | ForEach-Object {
            Rename-Item -Path $_.FullName -NewName "Certificate.cer"
          }
      # Move .msix, .cer, and .msixbundle files from subfolders to the Packages folder
      - name: Move files to the Packages folder
        run: |
          $fileTypes = "*.msix", "*.cer", "*.msixbundle"
          foreach ($fileType in $fileTypes) {
            Get-ChildItem -Path "${{ env.Solution_Name }}\\Packages" -Filter $fileType -Recurse -Depth 1 | ForEach-Object {
              $destinationFile = "${{ env.Solution_Name }}\\Packages\\" + $_.Name
              if (-Not (Test-Path -Path $destinationFile)) {
                Move-Item -Path $_.FullName -Destination $destinationFile
              }
            }
          }
      - name: Display disk tree
        run: |
          Get-ChildItem -Recurse | Sort-Object Length -Descending
      # Upload the MSIX package: https://github.com/marketplace/actions/upload-a-build-artifact
      - name: Upload MSIX package
        uses: actions/upload-artifact@v4
        with:
          name: MSIX Package
          path: |
            ${{ env.Solution_Name }}\\Packages\*.cer
            ${{ env.Solution_Name }}\\Packages\*.msixbundle
            ${{ env.Solution_Name }}\\Packages\*.msix
      - name: –ò–∑–≤–ª–µ—á—å –≤–µ—Ä—Å–∏—é
        id: get_version
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $csprojPath = "D:\a\$repoName\$repoName\VK UI3\VK UI3.csproj"
          $doc = New-Object xml
          $doc.Load((Convert-Path $csprojPath))
          $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText
          echo "::set-output name=VERSION::$version"
          echo "–í–µ—Ä—Å–∏—è: $version"
        continue-on-error: true
        if: github.event.inputs.release == 'true'

      - name: –ü–æ–¥—Å—Ç–∞–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é –≤ Package.appxmanifest
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $csproj = "D:\a\$repoName\$repoName\VK UI3\VK UI3.csproj"
          $manifest = "D:\a\$repoName\$repoName\VK UI3\Package.appxmanifest"
          [xml]$doc = Get-Content $csproj
          $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText
          (Get-Content $manifest) -replace 'Version="[^"]*"', 'Version="' + $version + '"' | Set-Content $manifest
        if: github.event.inputs.release == 'true'

      - name: –í—ã–≤–µ—Å—Ç–∏ –≤–µ—Ä—Å–∏—é
        run: |
          echo "–ò–∑–≤–ª–µ—á–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: ${{ steps.get_version.outputs.VERSION }}"
      - name: –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–ª–∏–∑—ã
        id: get_releases
        run: |
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
          }
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
          echo "::set-output name=releases::$releases"
        shell: pwsh
        if: github.event.inputs.release == 'true'

      - name: –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞
        id: check_release
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
          }
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
          $release = $releases | Where-Object { $_.tag_name -eq $version -and $_.draft -eq $false -and $_.prerelease -eq $false }
          if ($release) {
            Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
            echo "::set-output name=exists::true"
          } else {
            Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version –Ω–µ –Ω–∞–π–¥–µ–Ω"
            echo "::set-output name=exists::false"
          }
        shell: pwsh
        if: github.event.inputs.release == 'true'

      - name: –°–æ–∑–¥–∞—Ç—å —Ä–µ–ª–∏–∑
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          release_name: ${{ github.event.inputs.namevers }}
          body: ${{ github.event.inputs.descr }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'

      - name: –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã –≤ —Ä–µ–ª–∏–∑
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.TOKEN }}
          file: ${{ env.Solution_Name }}/Packages/*
          asset_name: ${{ env.Solution_Name }}-release-files
          tag: ${{ steps.get_version.outputs.VERSION }}
          overwrite: true
          file_glob: true
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'

      - name: –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          RELEASE_URL: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }}
        run: |
          $telegramBotToken = '${{ secrets.TELEGRAM_BOT_TOKEN }}'
          $telegramChatId = '${{ secrets.TELEGRAM_CHAT_ID }}'
          $releaseUrl = 'https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }}'
          $message = @"
          <b>üéâ –ù–æ–≤—ã–π —Ä–µ–ª–∏–∑:</b> ${{ github.event.inputs.namevers }}
          <b>üì¶ –í–µ—Ä—Å–∏—è:</b> ${{ steps.get_version.outputs.VERSION }}
          <b>üìù –û–ø–∏—Å–∞–Ω–∏–µ:</b> ${{ github.event.inputs.descr }}
          <b>üîó <a href='$releaseUrl'>–°—Å—ã–ª–∫–∞ –Ω–∞ —Ä–µ–ª–∏–∑</a></b>
          "@
          $uri = 'https://api.telegram.org/bot' + $telegramBotToken + '/sendMessage'
          $body = @{
              chat_id = $telegramChatId
              text = $message
              parse_mode = 'HTML'
          }
          $bodyJson = $body | ConvertTo-Json -Compress
          Invoke-RestMethod -Uri $uri -Method Post -Body $bodyJson -ContentType 'application/json'
