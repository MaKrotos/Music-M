name: –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞ Music M with EXE NEW WWWW

on:
  workflow_dispatch:
    inputs:
      namevers:
        description: "–ù–∞–∑–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "ü§ñ –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞"
      descr:
        description: "–û–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "‚ùå –û–ø–∏—Å–∞–Ω–∏–µ —Å–±–æ—Ä–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
      release:
        description: "–í—ã–∫–∏–Ω—É—Ç—å –≤ —Ä–µ–ª–∏–∑?"
        required: true
        default: false
        type: boolean
      prerelease:
        description: "–ü—Ä–µ—Ä–µ–ª–∏–∑?"
        required: true
        default: true
        type: boolean

  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    strategy:
      matrix:
        configuration: [Release]
        platform: [x64]

    runs-on:
      windows-latest # –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ä–∞–Ω–Ω–µ—Ä–æ–≤
      # —Å–º. https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    env:
      Solution_Name: "VK UI3 (Package)" # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –∏–º—è –≤–∞—à–µ–≥–æ —Ä–µ—à–µ–Ω–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, App1.sln.
      Solution_Name_Unpacked: "VK UI3"
      Configuration_unpacked: Unpacked

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          node-version: 16
          fetch-depth: 0

      # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤ base64 pfx –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º Signing_Certificate
      - name: Decode the pfx
        run: |
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
      - name: –û–±–Ω–æ–≤–∏—Ç—å TOKEN_STAT_SLY
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $content = Get-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs"
          $updatedContent = $content -replace 'Environment.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)', '"${{ secrets.TOKEN_STAT_SLY }}"'
          Set-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs" -Value $updatedContent
          Write-Output $updatedContent
      - name: Display disk tree
        run: |
          Get-ChildItem -Recurse | Sort-Object Length -Descending
      # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å .NET Core
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      # –î–æ–±–∞–≤–∏—Ç—å MSBuild –≤ PATH: https://github.com/microsoft/setup-msbuild
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2

        ################################
      - name: –ò–∑–≤–ª–µ—á—å –≤–µ—Ä—Å–∏—é
        id: get_version
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $csprojPath = "D:\a\$repoName\$repoName\VK UI3\VK UI3.csproj"
          $doc = New-Object xml
          $doc.Load((Convert-Path $csprojPath))
          $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText
          echo "::set-output name=VERSION::$version"
          echo "–í–µ—Ä—Å–∏—è: $version"
        continue-on-error: true

      - name: –ü–æ–¥—Å—Ç–∞–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é –≤ Package.appxmanifest
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $csproj = "D:\a\$repoName\$repoName\VK UI3\VK UI3.csproj"
          $manifest = "D:\a\$repoName\$repoName\VK UI3 (Package)\Package.appxmanifest"
          [xml]$doc = Get-Content $csproj
          $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText.Trim()
          [xml]$xml = Get-Content $manifest
          $xml.Package.Identity.Version = $version
          $xml.Save($manifest)

      - name: Upload Package.appxmanifest as artifact
        uses: actions/upload-artifact@v4
        with:
          name: PackageAppxManifest
          path: D:\a\Music-M\Music-M\VK UI3 (Package)\Package.appxmanifest
          
      - name: Clean publish directories
        run: |
          Remove-Item -Recurse -Force publish-x64, publish-x86, publish-arm64 -ErrorAction SilentlyContinue


        
        ################################

      # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–∞–ø–∫–∏ obj RuntimeIdentifiers
      - name: Restore the application
        run: msbuild $env:Solution_Name /t:Restore /p:Configuration=$env:Configuration
        env:
          Configuration: ${{ matrix.configuration }}

      - name: Print working directory
        run: |
          Write-Host "Current working directory: $(Get-Location)"
      - name: Get Certificate Thumbprint and Replace in Project File
        run: |
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -AsPlainText -Force
          $pfxCert = Get-PfxCertificate -FilePath $certificatePath -Password $pfxPassword
          Write-Host "Certificate Thumbprint: $($pfxCert.Thumbprint)"
          $projectFile = "VK UI3 (Package)/VK UI3 (Package).wapproj"
          $content = Get-Content -Path $projectFile -Raw
          $content = $content -replace '(?<=<PackageCertificateThumbprint>).+?(?=</PackageCertificateThumbprint>)', $pfxCert.Thumbprint
          Set-Content -Path $projectFile -Value $content
      - name: Install PFX certificate
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          $password = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password $password
      # –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–∫–µ—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –ø—É—Ç–µ–º —Å–±–æ—Ä–∫–∏ –∏ —É–ø–∞–∫–æ–≤–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞
      - name: Create the app package
        run: |
          $platforms = "x64", "x86", "ARM64"
          foreach ($platform in $platforms) {
            $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
            msbuild $env:Solution_Name /p:Configuration=$env:Configuration /p:Platform=$platform /p:UapAppxPackageBuildMode=$env:Appx_Package_Build_Mode /p:AppxBundle=$env:Appx_Bundle /p:PackageCertificateKeyFile="$certificatePath" /p:PackageCertificatePassword="${{ secrets.PFX_PASSWORD }}" /p:AppxPackageDir="$env:Appx_Package_Dir" /p:GenerateAppxPackageOnBuild=true /p:TOKEN_STAT_SLY="${{ secrets.TOKEN_STAT_SLY }}"
          }
        env:
          Appx_Bundle: Never
          Appx_Package_Build_Mode: SideloadOnly
          Appx_Package_Dir: Packages\
          Configuration: ${{ matrix.configuration }}
          TOKEN_STAT_SLY: ${{ secrets.TOKEN_STAT_SLY }}

      # –£–¥–∞–ª–∏—Ç—å pfx
      - name: Remove the pfx
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          Remove-Item -path "$certificatePath"
      # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å .cer —Ñ–∞–π–ª
      - name: Rename the .cer file
        run: |
          Get-ChildItem -Path "${{ env.Solution_Name }}\\Packages" -Filter *.cer -Recurse -Depth 1 | ForEach-Object {
            Rename-Item -Path $_.FullName -NewName "Certificate.cer"
          }
      # Move .msix, .cer, and .msixbundle files from subfolders to the Packages folder
      - name: Move files to the Packages folder
        run: |
          $fileTypes = "*.msix", "*.cer", "*.msixbundle"
          foreach ($fileType in $fileTypes) {
            Get-ChildItem -Path "${{ env.Solution_Name }}\\Packages" -Filter $fileType -Recurse -Depth 1 | ForEach-Object {
              $destinationFile = "${{ env.Solution_Name }}\\Packages\\" + $_.Name
              if (-Not (Test-Path -Path $destinationFile)) {
                Move-Item -Path $_.FullName -Destination $destinationFile
              }
            }
          }
      - name: Display disk tree
        run: |
          Get-ChildItem -Recurse | Sort-Object Length -Descending
      # Upload the MSIX package: https://github.com/marketplace/actions/upload-a-build-artifact
      - name: Upload MSIX package
        uses: actions/upload-artifact@v4
        with:
          name: MSIX Package
          path: |
            ${{ env.Solution_Name }}\\Packages\*.cer
            ${{ env.Solution_Name }}\\Packages\*.msixbundle
            ${{ env.Solution_Name }}\\Packages\*.msix
      
      - name: –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–ª–∏–∑—ã
        id: get_releases
        run: |
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
          }
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
          echo "::set-output name=releases::$releases"
        shell: pwsh
        if: github.event.inputs.release == 'true'








#-------------------------------------------------------EXE





      - name: Clean build artifacts
        run: msbuild $env:Solution_Name /t:Clean /p:Configuration=$env:Configuration
        env:
          Configuration: ${{ matrix.configuration }}\

      # PFX
      - name: Decode PFX
        run: |
          $bytes = [Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certPath = "${{ github.workspace }}\signcert.pfx"
          [IO.File]::WriteAllBytes($certPath, $bytes)

      # 1. –°–±–æ—Ä–∫–∞
      - name: Build EXE
        shell: pwsh
        run: |
          $arches = @(
            @{ Platform = "x64";   RID = "win-x64"   },
            @{ Platform = "x86";   RID = "win-x86"   },
            @{ Platform = "ARM64"; RID = "win-arm64" }
          )
      
          foreach ($a in $arches) {
            Write-Host "=== Build $($a.Platform) ==="
            msbuild "$env:Solution_Name_Unpacked\$env:Solution_Name_Unpacked.csproj" `
              "/p:Configuration=$env:Configuration_unpacked" `
              "/p:Platform=$($a.Platform)" `
              "/p:RuntimeIdentifier=$($a.RID)" `
              /restore `
              /p:DisableRuntimeIdentifierInference=true `
              /p:EnableNETAnalyzers=false `
              /p:WarningLevel=0 `
              /p:TreatWarningsAsErrors=false `
              /clp:ErrorsOnly

          }

# 2. –ü–æ–¥–ø–∏—Å—å
      - name: Sign exe
        shell: pwsh
        run: |
          $certPath = "${{ github.workspace }}\signcert.pfx"
          $password = "${{ secrets.PFX_PASSWORD }}"
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
                      Where-Object { $_.FullName -match 'x64' } |
                      Select-Object -First 1 -ExpandProperty FullName
          if (-not $signtool) { throw "signtool.exe –Ω–µ –Ω–∞–π–¥–µ–Ω" }
      
          $arches = @("x64","x86","ARM64")
          foreach ($platform in $arches) {
            $exe = Get-ChildItem "$env:Solution_Name_Unpacked\bin\$platform\$env:Configuration_unpacked" -Recurse -Include *.exe | Select-Object -First 1
            if (-not $exe) { throw "–ù–µ –Ω–∞–π–¥–µ–Ω exe –¥–ª—è $platform" }
            & $signtool sign /f $certPath /p $password /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exe.FullName
          }

      # 3. –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–æ–π build‚Äë–ø–∞–ø–∫–∏
      - name: Package build folders
        shell: pwsh
        run: |
          $arches = @("x64","x86","ARM64")
          foreach ($platform in $arches) {
            $buildDir = Join-Path "$env:Solution_Name_Unpacked\bin" "$platform\$env:Configuration_unpacked"
            if (-not (Test-Path $buildDir)) { throw "–ü–∞–ø–∫–∞ —Å–±–æ—Ä–∫–∏ –¥–ª—è $platform –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" }
      
            $zipName = "VK_UI3_$platform.zip"
            if (Test-Path $zipName) { Remove-Item $zipName -Force }
      
            Compress-Archive -Path "$buildDir\*" -DestinationPath $zipName -Force
          }





#------------------------------------------


      - name: –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞
        id: check_release
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $headers = @{
            "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
          }
          try {
            $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
            $release = $releases | Where-Object { $_.tag_name -eq $version -and $_.draft -eq $false -and $_.prerelease -eq $false }
            if ($release) {
              Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
              echo "exists=true" >> $env:GITHUB_OUTPUT
            } else {
              Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version –Ω–µ –Ω–∞–π–¥–µ–Ω"
              echo "exists=false" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Host "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ä–µ–ª–∏–∑–æ–≤: $($_.Exception.Message)"
            echo "exists=false" >> $env:GITHUB_OUTPUT
          }
        shell: pwsh
        if: github.event.inputs.release == 'true'
      
      - name: –°–æ–∑–¥–∞—Ç—å —Ä–µ–ª–∏–∑
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          release_name: ${{ github.event.inputs.namevers }}
          body: ${{ github.event.inputs.descr }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
        
      
      # –ó–∞–≥—Ä—É–∑–∫–∞ –≤ —Ä–µ–ª–∏–∑
      - name: Upload zips to release
        uses: softprops/action-gh-release@v1
        with:
          files: VK_UI3_*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
      
      - name: –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã –≤ —Ä–µ–ª–∏–∑
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.Solution_Name }}/Packages/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
