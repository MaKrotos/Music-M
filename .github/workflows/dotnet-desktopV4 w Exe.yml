name: –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞ Music M (Unpacked - –≤—Å–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã)

on:
  workflow_dispatch:
    inputs:
      namevers:
        description: "–ù–∞–∑–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "ü§ñ –ê–≤—Ç–æ—Å–±–æ—Ä–∫–∞"
      descr:
        description: "–û–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞"
        required: true
        default: "‚ùå –û–ø–∏—Å–∞–Ω–∏–µ —Å–±–æ—Ä–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
      release:
        description: "–í—ã–∫–∏–Ω—É—Ç—å –≤ —Ä–µ–ª–∏–∑?"
        required: true
        default: false
        type: boolean
      prerelease:
        description: "–ü—Ä–µ—Ä–µ–ª–∏–∑?"
        required: true
        default: true
        type: boolean

  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    strategy:
      matrix:
        # –£–∫–∞–∑–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä –¥–ª—è —Å–±–æ—Ä–∫–∏
        rid: [win-x64, win-x86, win-arm64]

    runs-on: windows-latest

    env:
      # –ò–º—è –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∫–∏
      Project_Name: "VK UI3"
      # –ò–º—è —Ä–µ—à–µ–Ω–∏—è
      Solution_Name: "VK UI3.sln"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          node-version: 16
          fetch-depth: 0

      # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤ base64 pfx –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º Signing_Certificate
      - name: Decode the pfx
        run: |
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)

      # –û–±–Ω–æ–≤–∏—Ç—å TOKEN_STAT_SLY
      - name: –û–±–Ω–æ–≤–∏—Ç—å TOKEN_STAT_SLY
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $content = Get-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs"
          $updatedContent = $content -replace 'Environment.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)', '"${{ secrets.TOKEN_STAT_SLY }}"'
          Set-Content -Path "D:\a\$repoName\$repoName\VK UI3\StaticParams.cs" -Value $updatedContent
          Write-Output $updatedContent

      # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å .NET Core
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
          
      # –î–æ–±–∞–≤–∏—Ç—å MSBuild –≤ PATH
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2

      # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
      - name: Restore dependencies
        run: dotnet restore ${{ env.Project_Name }}\${{ env.Project_Name }}.csproj

      # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç, —á—Ç–æ–±—ã signtool –º–æ–≥ –µ–≥–æ –Ω–∞–π—Ç–∏
      - name: Install PFX certificate
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          $password = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password $password

      # –°–±–æ—Ä–∫–∞, –ø—É–±–ª–∏–∫–∞—Ü–∏—è –∏ –ø–æ–¥–ø–∏—Å—å –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞
      - name: Build, Sign, and Zip the executable
        env:
          SIGN_PASSWORD: ${{ secrets.PFX_PASSWORD }}
        run: |
          $projectFile = "${{ env.Project_Name }}\${{ env.Project_Name }}.csproj"
          $outputDir = "build_output"
          
          # –ü—É–±–ª–∏–∫—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–∞–∫ –∞–≤—Ç–æ–Ω–æ–º–Ω—ã–π –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª
          dotnet publish `
            $projectFile `
            -c Unpacked `
            -r ${{ matrix.rid }} `
            --self-contained true `
            -o "$outputDir" `
            /p:PublishSingleFile=true
            
          $exePath = Get-ChildItem -Path "$outputDir" -Filter "*.exe" | Select-Object -First 1 | ForEach-Object { $_.FullName }
          
          if (-not $exePath) {
            throw "–ò—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ $outputDir"
          }
          
          # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª
          $signToolPath = (Get-Item "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe").FullName | Select-Object -First 1
          
          if ($signToolPath) {
            Write-Host "–ù–∞–π–¥–µ–Ω Signtool: $signToolPath"
            & "$signToolPath" sign /f "${{ github.workspace }}\GitHubActionsWorkflow.pfx" /p "${{ secrets.PFX_PASSWORD }}" /t http://timestamp.digicert.com /v $exePath
          } else {
            Write-Host "Signtool –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–¥–ø–∏—Å—å –ø—Ä–æ–ø—É—â–µ–Ω–∞."
          }
          
          # –£–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –≤ ZIP-–∞—Ä—Ö–∏–≤
          $zipName = "${{ env.Project_Name }}_${{ matrix.rid }}.zip"
          Compress-Archive -Path "$outputDir\*" -DestinationPath "$zipName" -Force
          
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –∫ ZIP-–∞—Ä—Ö–∏–≤—É –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å—Ä–µ–¥—ã, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Å–ª–µ–¥—É—é—â–µ–º —à–∞–≥–µ
          echo "::set-output name=zip_file_path::$zipName"
          echo "::set-output name=zip_file_name::$zipName"

      # –£–¥–∞–ª–∏—Ç—å pfx
      - name: Remove the pfx
        run: |
          $certificatePath = "${{ github.workspace }}\GitHubActionsWorkflow.pfx"
          Remove-Item -path "$certificatePath"
      
      # –ó–∞–≥—Ä—É–∂–∞–µ–º ZIP-–∞—Ä—Ö–∏–≤—ã –∫–∞–∫ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Å–±–æ—Ä–∫–∏
      - name: Upload zip artifact
        uses: actions/upload-artifact@v4
        with:
          name: Executable ${{ matrix.rid }}
          path: "*.zip"

      # === –®–∞–≥–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–µ–ª–∏–∑–∞ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ===
      
      - name: –ò–∑–≤–ª–µ—á—å –≤–µ—Ä—Å–∏—é
        id: get_version
        run: |
          $repoName = "${{ github.repository }}".Split('/')[1]
          $csprojPath = "D:\a\$repoName\$repoName\${{ env.Project_Name }}\${{ env.Project_Name }}.csproj"
          $doc = New-Object xml
          $doc.Load((Convert-Path $csprojPath))
          # –ò—â–µ–º —Ç–µ–≥ <Version>
          $version = $doc.SelectSingleNode('//Version').InnerText
          echo "::set-output name=VERSION::$version"
          echo "–í–µ—Ä—Å–∏—è: $version"
        continue-on-error: true
        if: github.event.inputs.release == 'true'

      - name: –í—ã–≤–µ—Å—Ç–∏ –≤–µ—Ä—Å–∏—é
        run: |
          echo "–ò–∑–≤–ª–µ—á–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: ${{ steps.get_version.outputs.VERSION }}"
      - name: –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞
        id: check_release
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
          }
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
          $release = $releases | Where-Object { $_.tag_name -eq $version -and $_.draft -eq $false -and $_.prerelease -eq $false }
          if ($release) {
            Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
            echo "::set-output name=exists::true"
          } else {
            Write-Host "–†–µ–ª–∏–∑ —Å —Ç–µ–≥–æ–º $version –Ω–µ –Ω–∞–π–¥–µ–Ω"
            echo "::set-output name=exists::false"
          }
        shell: pwsh
        if: github.event.inputs.release == 'true'

      - name: –°–æ–∑–¥–∞—Ç—å —Ä–µ–ª–∏–∑
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          release_name: ${{ github.event.inputs.namevers }}
          body: ${{ github.event.inputs.descr }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'

      - name: –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã –≤ —Ä–µ–ª–∏–∑
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.TOKEN }}
          file: "*.zip"
          tag: ${{ steps.get_version.outputs.VERSION }}
          overwrite: true
          file_glob: true
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'

      - name: –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          RELEASE_URL: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }}
        run: |
          $telegramBotToken = '${{ secrets.TELEGRAM_BOT_TOKEN }}'
          $telegramChatId = '${{ secrets.TELEGRAM_CHAT_ID }}'
          $releaseUrl = 'https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }}'
          $message = @"
          <b>üéâ –ù–æ–≤—ã–π —Ä–µ–ª–∏–∑:</b> ${{ github.event.inputs.namevers }}
          <b>üì¶ –í–µ—Ä—Å–∏—è:</b> ${{ steps.get_version.outputs.VERSION }}
          <b>üìù –û–ø–∏—Å–∞–Ω–∏–µ:</b> ${{ github.event.inputs.descr }}
          <b>üîó <a href='$releaseUrl'>–°—Å—ã–ª–∫–∞ –Ω–∞ —Ä–µ–ª–∏–∑</a></b>
          "@
          $uri = 'https://api.telegram.org/bot' + $telegramBotToken + '/sendMessage'
          $body = @{
              chat_id = $telegramChatId
              text = $message
              parse_mode = 'HTML'
          }
          $bodyJson = $body | ConvertTo-Json -Compress
          Invoke-RestMethod -Uri $uri -Method Post -Body $bodyJson -ContentType 'application/json'
