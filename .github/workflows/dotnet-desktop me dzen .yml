name: Build and Release

env:
  REPO_NAME: ${{ github.event.repository.name }}
  BUILD_PATH: D:\a\$REPO_NAME\$REPO_NAME
  ARTIFACTS_PATH: Packages\
  SOLUTION_NAME: VK UI3.sln
  SOLUTION_NAME_UNPACKED: VK UI3 unpacked
  CONFIGURATION: Release
  CONFIGURATION_UNPACKED: Release
  NUMBER_OF_PROCESSORS: 2

on:
  workflow_dispatch:
    inputs:
      release:
        description: 'Create GitHub release'
        required: true
        default: 'false'
        type: boolean
      namevers:
        description: 'Release name'
        required: false
        default: 'New Release'
        type: string
      descr:
        description: 'Release description'
        required: false
        default: 'Automatic release'
        type: string
      prerelease:
        description: 'Is prerelease?'
        required: false
        default: false
        type: boolean

jobs:
  build-and-release:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup common variables
        id: setup_vars
        run: |
          Write-Log "INFO" "Setting up common variables"
          $projectPath = "${{ env.BUILD_PATH }}\VK UI3"
          echo "projectPath=$projectPath" >> $env:GITHUB_OUTPUT
          Write-Log "DEBUG" "Project path: $projectPath"
          
      - name: Setup structured logging
        id: setup_logging
        run: |
          function Write-Log {
            param(
              [ValidateSet('DEBUG','INFO','WARN','ERROR')]
              [string]$Level,
              [string]$Message
            )
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $color = @{
              'DEBUG' = 'Gray'
              'INFO'  = 'Green'
              'WARN'  = 'Yellow'
              'ERROR' = 'Red'
            }
            Write-Host "[$timestamp] [$Level] $Message" -ForegroundColor $color[$Level]
          }
          echo "::set-output name=log_func::Write-Log"
          
      - name: Check required files
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Checking required files"
          
          $requiredFiles = @(
            "${{ steps.setup_vars.outputs.projectPath }}\StaticParams.cs",
            "${{ env.BUILD_PATH }}\VK UI3\VK UI3.csproj",
            "${{ env.BUILD_PATH }}\VK UI3 (Package)\Package.appxmanifest"
          )
          
          foreach ($file in $requiredFiles) {
            if (-not (Test-Path $file)) {
              & $logFunc "ERROR" "Required file not found: $file"
              exit 1
            }
            & $logFunc "DEBUG" "File found: $file"
          }
          
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: Replace environment variable in code
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $staticParamsPath = "${{ steps.setup_vars.outputs.projectPath }}\StaticParams.cs"
          
          & $logFunc "INFO" "Replacing environment variable in StaticParams.cs"
          $content = Get-Content -Path $staticParamsPath -Raw
          
          if ($content -match 'Environment\.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)') {
            $updatedContent = $content -replace 'Environment\.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)', '"${{ secrets.TOKEN_STAT_SLY }}"'
            Set-Content -Path $staticParamsPath -Value $updatedContent -Encoding UTF8
            & $logFunc "INFO" "Successfully replaced TOKEN_STAT_SLY"
          } else {
            & $logFunc "WARN" "TOKEN_STAT_SLY pattern not found in StaticParams.cs"
          }
          
      - name: Setup .NET and MSBuild
        uses: ./.github/actions/setup-build
        with:
          dotnet-version: '8.0.x'
          solution-name: ${{ env.SOLUTION_NAME }}
          
      - name: Extract version from project
        id: get_version
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $csprojPath = "${{ steps.setup_vars.outputs.projectPath }}\VK UI3.csproj"
          
          & $logFunc "INFO" "Extracting version from $csprojPath"
          try {
            [xml]$doc = Get-Content $csprojPath
            $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText.Trim()
            
            if ([string]::IsNullOrWhiteSpace($version)) {
              throw "Version not found in csproj"
            }
            
            & $logFunc "INFO" "Extracted version: $version"
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
            echo "version=$version" >> $env:GITHUB_OUTPUT
          } catch {
            & $logFunc "ERROR" "Failed to extract version: $_"
            exit 1
          }
          
      - name: Update manifest with version
        run: |
          $logFunc = ${{ steps.setup_vars.outputs.log_func }}
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $manifestPath = "${{ env.BUILD_PATH }}\VK UI3 (Package)\Package.appxmanifest"
          
          & $logFunc "INFO" "Updating Package.appxmanifest with version $version"
          
          [xml]$xml = Get-Content $manifestPath
          $xml.Package.Identity.Version = $version
          $xml.Save($manifestPath)
          
          & $logFunc "INFO" "Successfully updated manifest"
          
      - name: Run code analysis
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Running code analysis"
          msbuild ${{ env.SOLUTION_NAME }} /p:RunCodeAnalysis=true /p:Configuration=${{ env.CONFIGURATION }}
        continue-on-error: true
        
      - name: Setup certificate securely
        id: setup_cert
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Setting up certificate"
          
          # Secure certificate handling
          $certBytes = [Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $tempCertPath = [System.IO.Path]::GetTempFileName() + ".pfx"
          [System.IO.File]::WriteAllBytes($tempCertPath, $certBytes)
          
          # Set restrictive permissions
          icacls $tempCertPath /inheritance:r /grant:r "Administrators:F" /grant:r "$env:USERNAME:R"
          
          $pfxPassword = ConvertTo-SecureString "${{ secrets.PFX_PASSWORD }}" -AsPlainText -Force
          $cert = Import-PfxCertificate -FilePath $tempCertPath -CertStoreLocation Cert:\LocalMachine\My -Password $pfxPassword
          
          echo "THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_OUTPUT
          echo "CERT_PATH=$tempCertPath" >> $env:GITHUB_OUTPUT
          
          & $logFunc "INFO" "Certificate installed with thumbprint: $($cert.Thumbprint)"
          
      - name: Update project with certificate thumbprint
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $thumbprint = "${{ steps.setup_cert.outputs.THUMBPRINT }}"
          $projectFile = "${{ env.BUILD_PATH }}\VK UI3 (Package)\VK UI3 (Package).wapproj"
          
          & $logFunc "INFO" "Updating project file with certificate thumbprint"
          
          $content = Get-Content -Path $projectFile -Raw
          $pattern = '(?<=<PackageCertificateThumbprint>).+?(?=</PackageCertificateThumbprint>)'
          
          if ($content -match $pattern) {
            $content = $content -replace $pattern, $thumbprint
            Set-Content -Path $projectFile -Value $content
            & $logFunc "INFO" "Successfully updated certificate thumbprint"
          } else {
            & $logFunc "WARN" "PackageCertificateThumbprint tag not found"
          }
          
      - name: Clean publish directories
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Cleaning publish directories"
          
          $dirs = @("publish-x64", "publish-x86", "publish-arm64", "Packages")
          foreach ($dir in $dirs) {
            if (Test-Path $dir) {
              Remove-Item -Recurse -Force $dir
              & $logFunc "DEBUG" "Cleaned directory: $dir"
            }
          }
          
      - name: Build MSIX packages for all architectures
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $certPath = "${{ steps.setup_cert.outputs.CERT_PATH }}"
          
          $platforms = @("x64", "x86", "ARM64")
          
          foreach ($platform in $platforms) {
            & $logFunc "INFO" "Building MSIX package for $platform"
            
            $result = msbuild ${{ env.SOLUTION_NAME }} `
              /p:Configuration=${{ env.CONFIGURATION }} `
              /p:Platform=$platform `
              /p:UapAppxPackageBuildMode=SideloadOnly `
              /p:AppxBundle=Never `
              /p:PackageCertificateKeyFile="$certPath" `
              /p:PackageCertificatePassword="${{ secrets.PFX_PASSWORD }}" `
              /p:AppxPackageDir="${{ env.ARTIFACTS_PATH }}" `
              /p:GenerateAppxPackageOnBuild=true `
              /p:TOKEN_STAT_SLY="${{ secrets.TOKEN_STAT_SLY }}" `
              /p:EnableNETAnalyzers=false `
              /p:Optimize=true `
              /p:DebugType=none `
              /m:${{ env.NUMBER_OF_PROCESSORS }} `
              /clp:ErrorsOnly `
              /flp:logfile=msbuild-$platform.log;verbosity=diagnostic
              
            if ($LASTEXITCODE -ne 0) {
              & $logFunc "ERROR" "Build failed for $platform"
              Get-Content "msbuild-$platform.log" | Select-Object -Last 50
              exit 1
            }
          }
          
      - name: Process and rename artifacts
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Processing build artifacts"
          
          # Rename .cer files
          Get-ChildItem -Path "${{ env.ARTIFACTS_PATH }}" -Filter *.cer -Recurse -Depth 1 | ForEach-Object {
            $newPath = Join-Path $_.Directory "Certificate.cer"
            Move-Item -Path $_.FullName -Destination $newPath -Force
            & $logFunc "DEBUG" "Renamed: $($_.Name) -> Certificate.cer"
          }
          
          # Move files to root artifacts directory
          $fileTypes = @("*.msix", "*.cer", "*.msixbundle")
          foreach ($fileType in $fileTypes) {
            Get-ChildItem -Path "${{ env.ARTIFACTS_PATH }}" -Filter $fileType -Recurse -Depth 1 | ForEach-Object {
              $destination = "${{ env.ARTIFACTS_PATH }}\" + $_.Name
              if (-not (Test-Path $destination)) {
                Move-Item -Path $_.FullName -Destination $destination -Force
                & $logFunc "DEBUG" "Moved: $($_.Name)"
              }
            }
          }
          
      - name: Build EXE packages (parallel)
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Building EXE packages in parallel"
          
          $jobs = @(
            @{ Platform = "x64"; RID = "win-x64" },
            @{ Platform = "x86"; RID = "win-x86" },
            @{ Platform = "ARM64"; RID = "win-arm64" }
          )
          
          $jobs | ForEach-Object -Parallel {
            $job = $_
            function Write-Log { param($l,$m) Write-Host "[$(Get-Date -Format 'HH:mm:ss')] [$l] [$($job.Platform)] $m" }
            
            Write-Log "INFO" "Starting build"
            
            # Restore dependencies
            msbuild "$using:solutionUnpacked" `
              "/p:Configuration=$using:configuration" `
              "/p:Platform=$($job.Platform)" `
              "/p:RuntimeIdentifier=$($job.RID)" `
              /t:Restore `
              /clp:ErrorsOnly
              
            # Build project
            msbuild "$using:solutionUnpacked" `
              "/p:Configuration=$using:configuration" `
              "/p:Platform=$($job.Platform)" `
              "/p:RuntimeIdentifier=$($job.RID)" `
              "/p:DisableRuntimeIdentifierInference=true" `
              "/p:EnableNETAnalyzers=false" `
              "/p:Optimize=true" `
              "/p:WarningLevel=0" `
              /m:$using:numProcs `
              /clp:ErrorsOnly
              
            Write-Log "INFO" "Build completed"
          } -ThrottleLimit 3
          
        env:
          solutionUnpacked: "${{ env.SOLUTION_NAME_UNPACKED }}\${{ env.SOLUTION_NAME_UNPACKED }}.csproj"
          configuration: ${{ env.CONFIGURATION_UNPACKED }}
          numProcs: ${{ env.NUMBER_OF_PROCESSORS }}
          
      - name: Sign EXE files
        uses: ./.github/actions/sign-artifacts
        with:
          pfx-base64: ${{ secrets.BASE64_ENCODED_PFX }}
          pfx-password: ${{ secrets.PFX_PASSWORD }}
          artifacts-path: "${{ env.BUILD_PATH }}"
          
      - name: Create ZIP archives
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $arches = @("x64", "x86", "ARM64")
          
          foreach ($arch in $arches) {
            $buildDir = "${{ env.BUILD_PATH }}\${{ env.SOLUTION_NAME_UNPACKED }}\bin\$arch\${{ env.CONFIGURATION_UNPACKED }}"
            
            if (Test-Path $buildDir) {
              $zipName = "VK_UI3_$arch.zip"
              & $logFunc "INFO" "Creating archive: $zipName"
              
              Compress-Archive -Path "$buildDir\*" -DestinationPath $zipName -CompressionLevel Optimal
              
              # Add metadata
              [PSCustomObject]@{
                Architecture = $arch
                Version = "${{ steps.get_version.outputs.VERSION }}"
                BuildDate = Get-Date -Format "yyyy-MM-dd"
                CommitHash = "${{ github.sha }}"
              } | ConvertTo-Json | Out-File "metadata-$arch.json"
            }
          }
          
      - name: Clean up temporary files
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Cleaning up temporary files"
          
          # Remove certificate file
          $certPath = "${{ steps.setup_cert.outputs.CERT_PATH }}"
          if (Test-Path $certPath) {
            Remove-Item $certPath -Force
          }
          
          # Clean build logs
          Remove-Item "msbuild-*.log" -ErrorAction SilentlyContinue
          
      - name: Upload MSIX artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('MSIX-Package-{0}-{1}', github.run_number, steps.get_version.outputs.VERSION) }}
          path: |
            ${{ env.ARTIFACTS_PATH }}/*.cer
            ${{ env.ARTIFACTS_PATH }}/*.msixbundle
            ${{ env.ARTIFACTS_PATH }}/*.msix
          retention-days: 90
          compression-level: 9
          
      - name: Upload EXE artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('EXE-Package-{0}-{1}', github.run_number, steps.get_version.outputs.VERSION) }}
          path: |
            VK_UI3_*.zip
            metadata-*.json
          retention-days: 90
          compression-level: 9
          
      - name: Check if release exists
        id: check_release
        if: github.event.inputs.release == 'true'
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          & $logFunc "INFO" "Checking if release $version exists"
          
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          try {
            $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
            $existingRelease = $releases | Where-Object { 
              $_.tag_name -eq $version -and $_.draft -eq $false 
            }
            
            if ($existingRelease) {
              & $logFunc "WARN" "Release with tag $version already exists"
              echo "exists=true" >> $env:GITHUB_OUTPUT
              echo "release_id=$($existingRelease.id)" >> $env:GITHUB_OUTPUT
            } else {
              & $logFunc "INFO" "Release $version does not exist"
              echo "exists=false" >> $env:GITHUB_OUTPUT
            }
          } catch {
            & $logFunc "ERROR" "Failed to check releases: $_"
            echo "exists=false" >> $env:GITHUB_OUTPUT
          }
          
      - name: Create GitHub release
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          name: ${{ github.event.inputs.namevers }}
          body: |
            ${{ github.event.inputs.descr }}
            
            **Build Details:**
            - Version: ${{ steps.get_version.outputs.VERSION }}
            - Commit: ${{ github.sha }}
            - Triggered by: ${{ github.actor }}
            - Build: ${{ github.run_number }}
            
            **Artifacts included:**
            ‚Ä¢ MSIX packages for x64, x86, ARM64
            ‚Ä¢ EXE packages for x64, x86, ARM64
            ‚Ä¢ Installation certificate
            
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
          files: |
            ${{ env.ARTIFACTS_PATH }}/*
            VK_UI3_*.zip
          token: ${{ secrets.TOKEN }}
          
      - name: Send Telegram notification
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
        run: |
          $logFunc = ${{ steps.setup_logging.outputs.log_func }}
          & $logFunc "INFO" "Sending Telegram notification"
          
          $message = @"
          üöÄ *New Release Published!*
          
          üì¶ *${{ github.event.inputs.namevers }}*
          ‚öôÔ∏è Version: `${{ steps.get_version.outputs.VERSION }}`
          
          ${{ github.event.inputs.descr }}
          
          üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }})
          üìÖ $(Get-Date -Format 'yyyy-MM-dd HH:mm')
          "@
          
          $body = @{
            chat_id = "${{ secrets.TELEGRAM_CHAT_ID }}"
            text = $message
            parse_mode = "Markdown"
            disable_web_page_preview = $true
          }
          
          Invoke-RestMethod `
            -Uri "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" `
            -Method Post `
            -Body ($body | ConvertTo-Json) `
            -ContentType "application/json"
            
      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            const issueTitle = `Build Failed: Run #${context.runNumber}`;
            const issueBody = `
            ## ‚ùå Build Failed
            
            **Workflow:** ${context.workflow}
            **Run:** #${context.runNumber}
            **Commit:** ${context.sha}
            **Triggered by:** ${context.actor}
            
            [View failed run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['build-failed']
            });
