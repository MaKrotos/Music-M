name: Build and Release

env:
  REPO_NAME: ${{ github.event.repository.name }}
  BUILD_PATH: D:\a\${{ github.event.repository.name }}\${{ github.event.repository.name }}
  ARTIFACTS_PATH: Packages\
  SOLUTION_NAME: VK UI3.sln
  SOLUTION_NAME_UNPACKED: VK UI3 unpacked
  CONFIGURATION: Release
  CONFIGURATION_UNPACKED: Release
  NUMBER_OF_PROCESSORS: 2

on:
  workflow_dispatch:
    inputs:
      release:
        description: 'Create GitHub release'
        required: true
        default: 'false'
        type: boolean
      namevers:
        description: 'Release name'
        required: false
        default: 'New Release'
        type: string
      descr:
        description: 'Release description'
        required: false
        default: 'Automatic release'
        type: string
      prerelease:
        description: 'Is prerelease?'
        required: false
        default: false
        type: boolean

jobs:
  build-and-release:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup common variables
        id: setup_vars
        run: |
          Write-Host "##[group]Setting up common variables"
          $projectPath = "${{ env.BUILD_PATH }}\VK UI3"
          echo "projectPath=$projectPath" >> $env:GITHUB_OUTPUT
          Write-Host "Project path: $projectPath"
          Write-Host "##[endgroup]"
          
      - name: Setup structured logging
        id: setup_logging
        run: |
          function Write-Log {
            param(
              [ValidateSet('DEBUG','INFO','WARN','ERROR')]
              [string]$Level,
              [string]$Message
            )
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $color = @{
              'DEBUG' = 'Gray'
              'INFO'  = 'Green'
              'WARN'  = 'Yellow'
              'ERROR' = 'Red'
            }
            Write-Host "[$timestamp] [$Level] $Message" -ForegroundColor $color[$Level]
          }
          echo "log_func=Write-Log" >> $env:GITHUB_OUTPUT
          
      - name: Check required files
        run: |
          Write-Host "##[group]Checking required files"
          
          $requiredFiles = @(
            "${{ steps.setup_vars.outputs.projectPath }}\StaticParams.cs",
            "${{ env.BUILD_PATH }}\VK UI3\VK UI3.csproj",
            "${{ env.BUILD_PATH }}\VK UI3 (Package)\Package.appxmanifest"
          )
          
          foreach ($file in $requiredFiles) {
            if (-not (Test-Path $file)) {
              Write-Error "Required file not found: $file"
              exit 1
            }
            Write-Host "‚úì File found: $file"
          }
          Write-Host "##[endgroup]"
          
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: Replace environment variable in code
        run: |
          Write-Host "##[group]Replacing environment variable in StaticParams.cs"
          $staticParamsPath = "${{ steps.setup_vars.outputs.projectPath }}\StaticParams.cs"
          
          if (Test-Path $staticParamsPath) {
            $content = Get-Content -Path $staticParamsPath -Raw
            
            if ($content -match 'Environment\.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)') {
              $updatedContent = $content -replace 'Environment\.GetEnvironmentVariable\("TOKEN_STAT_SLY"\)', '"${{ secrets.TOKEN_STAT_SLY }}"'
              Set-Content -Path $staticParamsPath -Value $updatedContent -Encoding UTF8
              Write-Host "‚úì Successfully replaced TOKEN_STAT_SLY"
            } else {
              Write-Warning "TOKEN_STAT_SLY pattern not found in StaticParams.cs"
            }
          } else {
            Write-Error "StaticParams.cs not found at: $staticParamsPath"
            exit 1
          }
          Write-Host "##[endgroup]"
          
      - name: Setup .NET and MSBuild
        run: |
          Write-Host "##[group]Setting up .NET and MSBuild"
          Write-Host "Installing .NET 8.0.x"
          Write-Host "##[endgroup]"
        shell: bash
          
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
          
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2
          
      - name: Extract version from project
        id: get_version
        run: |
          Write-Host "##[group]Extracting version from project"
          $csprojPath = "${{ steps.setup_vars.outputs.projectPath }}\VK UI3.csproj"
          
          Write-Host "Reading: $csprojPath"
          try {
            [xml]$doc = Get-Content $csprojPath
            $version = $doc.SelectSingleNode('//AppxPackageVersion').InnerText.Trim()
            
            if ([string]::IsNullOrWhiteSpace($version)) {
              throw "Version not found in csproj"
            }
            
            Write-Host "‚úì Extracted version: $version"
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
            echo "version=$version" >> $env:GITHUB_OUTPUT
          } catch {
            Write-Error "Failed to extract version: $_"
            exit 1
          }
          Write-Host "##[endgroup]"
          
      - name: Update manifest with version
        run: |
          Write-Host "##[group]Updating Package.appxmanifest with version"
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $manifestPath = "${{ env.BUILD_PATH }}\VK UI3 (Package)\Package.appxmanifest"
          
          Write-Host "Version: $version"
          Write-Host "Manifest: $manifestPath"
          
          if (Test-Path $manifestPath) {
            [xml]$xml = Get-Content $manifestPath
            $xml.Package.Identity.Version = $version
            $xml.Save($manifestPath)
            Write-Host "‚úì Successfully updated manifest"
          } else {
            Write-Error "Manifest not found: $manifestPath"
            exit 1
          }
          Write-Host "##[endgroup]"
          
      - name: Run code analysis
        run: |
          Write-Host "##[group]Running code analysis"
          msbuild ${{ env.SOLUTION_NAME }} /p:RunCodeAnalysis=true /p:Configuration=${{ env.CONFIGURATION }}
          Write-Host "##[endgroup]"
        continue-on-error: true
        
      - name: Setup certificate securely
        id: setup_cert
        run: |
          Write-Host "##[group]Setting up certificate"
          
          # Secure certificate handling
          $certBytes = [Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $tempCertPath = [System.IO.Path]::GetTempFileName() + ".pfx"
          [System.IO.File]::WriteAllBytes($tempCertPath, $certBytes)
          
          # Set restrictive permissions
          icacls $tempCertPath /inheritance:r /grant:r "Administrators:F" /grant:r "$env:USERNAME:R"
          
          $pfxPassword = ConvertTo-SecureString "${{ secrets.PFX_PASSWORD }}" -AsPlainText -Force
          $cert = Import-PfxCertificate -FilePath $tempCertPath -CertStoreLocation Cert:\LocalMachine\My -Password $pfxPassword
          
          echo "THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_OUTPUT
          echo "CERT_PATH=$tempCertPath" >> $env:GITHUB_OUTPUT
          
          Write-Host "‚úì Certificate installed with thumbprint: $($cert.Thumbprint)"
          Write-Host "##[endgroup]"
          
      - name: Update project with certificate thumbprint
        run: |
          Write-Host "##[group]Updating project file with certificate thumbprint"
          $thumbprint = "${{ steps.setup_cert.outputs.THUMBPRINT }}"
          $projectFile = "${{ env.BUILD_PATH }}\VK UI3 (Package)\VK UI3 (Package).wapproj"
          
          Write-Host "Thumbprint: $thumbprint"
          Write-Host "Project file: $projectFile"
          
          if (Test-Path $projectFile) {
            $content = Get-Content -Path $projectFile -Raw
            $pattern = '(?<=<PackageCertificateThumbprint>).+?(?=</PackageCertificateThumbprint>)'
            
            if ($content -match $pattern) {
              $content = $content -replace $pattern, $thumbprint
              Set-Content -Path $projectFile -Value $content
              Write-Host "‚úì Successfully updated certificate thumbprint"
            } else {
              Write-Warning "PackageCertificateThumbprint tag not found"
            }
          } else {
            Write-Error "Project file not found: $projectFile"
            exit 1
          }
          Write-Host "##[endgroup]"
          
      - name: Clean publish directories
        run: |
          Write-Host "##[group]Cleaning publish directories"
          
          $dirs = @("publish-x64", "publish-x86", "publish-arm64", "Packages")
          foreach ($dir in $dirs) {
            if (Test-Path $dir) {
              Remove-Item -Recurse -Force $dir
              Write-Host "‚úì Cleaned directory: $dir"
            }
          }
          Write-Host "##[endgroup]"
          
      - name: Build MSIX packages for all architectures
        run: |
          Write-Host "##[group]Building MSIX packages"
          $certPath = "${{ steps.setup_cert.outputs.CERT_PATH }}"
          
          $platforms = @("x64", "x86", "ARM64")
          
          foreach ($platform in $platforms) {
            Write-Host "--- Building MSIX package for $platform ---"
            
            $result = msbuild ${{ env.SOLUTION_NAME }} `
              /p:Configuration=${{ env.CONFIGURATION }} `
              /p:Platform=$platform `
              /p:UapAppxPackageBuildMode=SideloadOnly `
              /p:AppxBundle=Never `
              /p:PackageCertificateKeyFile="$certPath" `
              /p:PackageCertificatePassword="${{ secrets.PFX_PASSWORD }}" `
              /p:AppxPackageDir="${{ env.ARTIFACTS_PATH }}" `
              /p:GenerateAppxPackageOnBuild=true `
              /p:TOKEN_STAT_SLY="${{ secrets.TOKEN_STAT_SLY }}" `
              /p:EnableNETAnalyzers=false `
              /p:Optimize=true `
              /p:DebugType=none `
              /m:${{ env.NUMBER_OF_PROCESSORS }} `
              /clp:ErrorsOnly `
              /flp:logfile=msbuild-$platform.log;verbosity=diagnostic
              
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Build failed for $platform"
              Get-Content "msbuild-$platform.log" | Select-Object -Last 50
              exit 1
            } else {
              Write-Host "‚úì Successfully built $platform"
            }
          }
          Write-Host "##[endgroup]"
          
      - name: Process and rename artifacts
        run: |
          Write-Host "##[group]Processing build artifacts"
          
          # Rename .cer files
          Get-ChildItem -Path "${{ env.ARTIFACTS_PATH }}" -Filter *.cer -Recurse -Depth 1 | ForEach-Object {
            $newPath = Join-Path $_.Directory "Certificate.cer"
            Move-Item -Path $_.FullName -Destination $newPath -Force
            Write-Host "‚úì Renamed: $($_.Name) -> Certificate.cer"
          }
          
          # Move files to root artifacts directory
          $fileTypes = @("*.msix", "*.cer", "*.msixbundle")
          foreach ($fileType in $fileTypes) {
            Get-ChildItem -Path "${{ env.ARTIFACTS_PATH }}" -Filter $fileType -Recurse -Depth 1 | ForEach-Object {
              $destination = "${{ env.ARTIFACTS_PATH }}\" + $_.Name
              if (-not (Test-Path $destination)) {
                Move-Item -Path $_.FullName -Destination $destination -Force
                Write-Host "‚úì Moved: $($_.Name)"
              }
            }
          }
          Write-Host "##[endgroup]"
          
      - name: Build EXE packages
        env:
          SOLUTION_UNPACKED_PATH: "${{ env.BUILD_PATH }}\${{ env.SOLUTION_NAME_UNPACKED }}\${{ env.SOLUTION_NAME_UNPACKED }}.csproj"
        run: |
          Write-Host "##[group]Building EXE packages"
          
          $jobs = @(
            @{ Platform = "x64"; RID = "win-x64" },
            @{ Platform = "x86"; RID = "win-x86" },
            @{ Platform = "ARM64"; RID = "win-arm64" }
          )
          
          foreach ($job in $jobs) {
            Write-Host "--- Building $($job.Platform) ---"
            
            # Restore dependencies
            msbuild "${{ env.SOLUTION_UNPACKED_PATH }}" `
              "/p:Configuration=${{ env.CONFIGURATION_UNPACKED }}" `
              "/p:Platform=$($job.Platform)" `
              "/p:RuntimeIdentifier=$($job.RID)" `
              /t:Restore `
              /clp:ErrorsOnly
              
            # Build project
            msbuild "${{ env.SOLUTION_UNPACKED_PATH }}" `
              "/p:Configuration=${{ env.CONFIGURATION_UNPACKED }}" `
              "/p:Platform=$($job.Platform)" `
              "/p:RuntimeIdentifier=$($job.RID)" `
              "/p:DisableRuntimeIdentifierInference=true" `
              "/p:EnableNETAnalyzers=false" `
              "/p:Optimize=true" `
              "/p:WarningLevel=0" `
              /m:${{ env.NUMBER_OF_PROCESSORS }} `
              /clp:ErrorsOnly
              
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úì Successfully built $($job.Platform)"
            } else {
              Write-Error "Build failed for $($job.Platform)"
              exit 1
            }
          }
          Write-Host "##[endgroup]"
          
      - name: Sign EXE files
        run: |
          Write-Host "##[group]Signing EXE files"
          
          $certBytes = [Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certPath = "${{ github.workspace }}\temp-sign.pfx"
          [IO.File]::WriteAllBytes($certPath, $certBytes)
          
          $pfxPassword = ConvertTo-SecureString "${{ secrets.PFX_PASSWORD }}" -AsPlainText -Force
          $cert = Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\LocalMachine\My -Password $pfxPassword
          
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
                      Where-Object { $_.FullName -match 'x64' } |
                      Select-Object -First 1 -ExpandProperty FullName
        
          if (-not $signtool) {
            throw "signtool.exe not found"
          }
          
          $arches = @("x64", "x86", "ARM64")
          foreach ($arch in $arches) {
            $exeFiles = Get-ChildItem "${{ env.BUILD_PATH }}\${{ env.SOLUTION_NAME_UNPACKED }}\bin\$arch\${{ env.CONFIGURATION_UNPACKED }}" -Recurse -Include *.exe
            
            foreach ($exe in $exeFiles) {
              Write-Host "Signing: $($exe.Name)"
              & $signtool sign /f "$certPath" /p "${{ secrets.PFX_PASSWORD }}" /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exe.FullName
              Write-Host "‚úì Signed: $($exe.Name)"
            }
          }
          
          Remove-Item $certPath -Force -ErrorAction SilentlyContinue
          Write-Host "##[endgroup]"
          
      - name: Create ZIP archives
        run: |
          Write-Host "##[group]Creating ZIP archives"
          $arches = @("x64", "x86", "ARM64")
          
          foreach ($arch in $arches) {
            $buildDir = "${{ env.BUILD_PATH }}\${{ env.SOLUTION_NAME_UNPACKED }}\bin\$arch\${{ env.CONFIGURATION_UNPACKED }}"
            
            if (Test-Path $buildDir) {
              $zipName = "VK_UI3_$arch.zip"
              Write-Host "Creating archive: $zipName"
              
              Compress-Archive -Path "$buildDir\*" -DestinationPath $zipName -CompressionLevel Optimal
              
              # Add metadata
              [PSCustomObject]@{
                Architecture = $arch
                Version = "${{ steps.get_version.outputs.VERSION }}"
                BuildDate = Get-Date -Format "yyyy-MM-dd"
                CommitHash = "${{ github.sha }}"
              } | ConvertTo-Json | Out-File "metadata-$arch.json"
              
              Write-Host "‚úì Created: $zipName"
            }
          }
          Write-Host "##[endgroup]"
          
      - name: Clean up temporary files
        run: |
          Write-Host "##[group]Cleaning up temporary files"
          
          # Remove certificate file
          $certPath = "${{ steps.setup_cert.outputs.CERT_PATH }}"
          if (Test-Path $certPath) {
            Remove-Item $certPath -Force
            Write-Host "‚úì Removed certificate file"
          }
          
          # Clean build logs
          Remove-Item "msbuild-*.log" -ErrorAction SilentlyContinue
          Write-Host "‚úì Cleaned build logs"
          Write-Host "##[endgroup]"
          
      - name: Upload MSIX artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('MSIX-Package-{0}-{1}', github.run_number, steps.get_version.outputs.VERSION) }}
          path: |
            ${{ env.ARTIFACTS_PATH }}/*.cer
            ${{ env.ARTIFACTS_PATH }}/*.msixbundle
            ${{ env.ARTIFACTS_PATH }}/*.msix
          retention-days: 90
          compression-level: 9
          
      - name: Upload EXE artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('EXE-Package-{0}-{1}', github.run_number, steps.get_version.outputs.VERSION) }}
          path: |
            VK_UI3_*.zip
            metadata-*.json
          retention-days: 90
          compression-level: 9
          
      - name: Check if release exists
        id: check_release
        if: github.event.inputs.release == 'true'
        run: |
          Write-Host "##[group]Checking if release exists"
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          Write-Host "Checking for release with tag: $version"
          
          $headers = @{
            "Authorization" = "token ${{ secrets.TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          try {
            $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases" -Headers $headers
            $existingRelease = $releases | Where-Object { 
              $_.tag_name -eq $version -and $_.draft -eq $false 
            }
            
            if ($existingRelease) {
              Write-Host "‚ö†Ô∏è Release with tag $version already exists"
              echo "exists=true" >> $env:GITHUB_OUTPUT
              echo "release_id=$($existingRelease.id)" >> $env:GITHUB_OUTPUT
            } else {
              Write-Host "‚úì Release $version does not exist"
              echo "exists=false" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Error "Failed to check releases: $_"
            echo "exists=false" >> $env:GITHUB_OUTPUT
          }
          Write-Host "##[endgroup]"
          
      - name: Create GitHub release
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          name: ${{ github.event.inputs.namevers }}
          body: |
            ${{ github.event.inputs.descr }}
            
            **Build Details:**
            - Version: ${{ steps.get_version.outputs.VERSION }}
            - Commit: ${{ github.sha }}
            - Triggered by: ${{ github.actor }}
            - Build: ${{ github.run_number }}
            
            **Artifacts included:**
            ‚Ä¢ MSIX packages for x64, x86, ARM64
            ‚Ä¢ EXE packages for x64, x86, ARM64
            ‚Ä¢ Installation certificate
            
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
          files: |
            ${{ env.ARTIFACTS_PATH }}/*
            VK_UI3_*.zip
          token: ${{ secrets.TOKEN }}
          
      - name: Send Telegram notification
        if: steps.check_release.outputs.exists == 'false' && github.event.inputs.release == 'true'
        run: |
          Write-Host "##[group]Sending Telegram notification"
          
          $message = @"
          üöÄ *New Release Published!*
          
          üì¶ *${{ github.event.inputs.namevers }}*
          ‚öôÔ∏è Version: `${{ steps.get_version.outputs.VERSION }}`
          
          ${{ github.event.inputs.descr }}
          
          üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.VERSION }})
          üìÖ $(Get-Date -Format 'yyyy-MM-dd HH:mm')
          "@
          
          $body = @{
            chat_id = "${{ secrets.TELEGRAM_CHAT_ID }}"
            text = $message
            parse_mode = "Markdown"
            disable_web_page_preview = $true
          }
          
          try {
            $response = Invoke-RestMethod `
              -Uri "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" `
              -Method Post `
              -Body ($body | ConvertTo-Json) `
              -ContentType "application/json"
              
            Write-Host "‚úì Telegram notification sent"
          } catch {
            Write-Warning "Failed to send Telegram notification: $_"
          }
          Write-Host "##[endgroup]"
            
      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            const issueTitle = `Build Failed: Run #${context.runNumber}`;
            const issueBody = `
            ## ‚ùå Build Failed
            
            **Workflow:** ${context.workflow}
            **Run:** #${context.runNumber}
            **Commit:** ${context.sha}
            **Triggered by:** ${context.actor}
            
            [View failed run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            `;
            
            try {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: ['build-failed']
              });
              console.log('‚úì Created issue for failed build');
            } catch (error) {
              console.error('Failed to create issue:', error.message);
            }
