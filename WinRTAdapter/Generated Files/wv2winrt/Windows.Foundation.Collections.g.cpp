// WARNING: Please don't edit this file. It was generated by wv2winrt v1.0.0.0
#include "pch.h"

#include "wv2winrt/asyncdispatch.h"
#include "wv2winrt/converter.h"
#include "wv2winrt/eventargsdispatch.h"
#include "wv2winrt/implicitstructs.g.h"
#include "wv2winrt/main.h"
#include "wv2winrt/returnaggregator.h"
#include "wv2winrt/uniquevariant.h"
#include "wv2winrt/Windows.Foundation.Collections.g.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/Windows.System.h"
#include "winrt/Windows.Storage.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Storage.Search.h"
#include "winrt/Windows.Data.Text.h"


namespace wv2winrt_impl
{
Namespace_Windows_Foundation_Collections::Namespace_Windows_Foundation_Collections(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

DispatchProperties Namespace_Windows_Foundation_Collections::s_dispatchProperties = nullptr;

HRESULT Namespace_Windows_Foundation_Collections::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Namespace_Windows_Foundation_Collections::GetIDsOfNames(REFIID riid,
                                                  LPOLESTR* names,
                                                  unsigned int namesCount,
                                                  LCID localeId,
                                                  DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Namespace_Windows_Foundation_Collections::Invoke(DISPID dispId,
                                           REFIID riid,
                                           LCID localeId,
                                           WORD flags,
                                           DISPPARAMS* dispParams,
                                           VARIANT* result,
                                           EXCEPINFO* excepInfo,
                                           UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                winrt::com_ptr<IDispatch> dispatch;
#pragma warning( push )
#pragma warning( disable: 4065 )
                switch (dispId)
                {

                    default:
                        hr = DISP_E_MEMBERNOTFOUND;
                        break;
                }
#pragma warning( pop )

                if (SUCCEEDED(hr))
                {
                    // Copy dispatch into output result
                    VARIANT dispatchAsVariant;
                    dispatchAsVariant.vt = VT_DISPATCH;
                    dispatchAsVariant.pdispVal = dispatch.detach();
                    *result = dispatchAsVariant;
                }
            }
        }
    }
    return hr;
}

}

#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_HSTRING__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_HSTRING__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_HSTRING__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_HSTRING_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::hstring>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVector_1_HSTRING_::Class_Windows_Foundation_Collections_IVector_1_HSTRING_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 20)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVector_1_HSTRING__dispatchProperties[] =
{
    L"append",
    L"clear",
    L"first",
    L"getAt",
    L"getMany",
    L"getView",
    L"indexOf",
    L"insertAt",
    L"removeAt",
    L"removeAtEnd",
    L"replaceAll",
    L"setAt",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVector_1_HSTRING_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVector_1_HSTRING__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVector_1_HSTRING_::s_dispatchIds[13] =
{
    7,
    9,
    12,
    1,
    10,
    2,
    3,
    5,
    6,
    8,
    11,
    4,
    14
};

HRESULT Class_Windows_Foundation_Collections_IVector_1_HSTRING_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVector_1_HSTRING__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_HSTRING_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_HSTRING_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 13))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_HSTRING_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_HSTRING_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method SetAt
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.SetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method InsertAt
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.InsertAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method RemoveAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.RemoveAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method Append
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.Append(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for method RemoveAtEnd
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.RemoveAtEnd(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::hstring>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for method ReplaceAll
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                    innerObject.ReplaceAll(
                                Converter<VARIANT, winrt::array_view<winrt::hstring>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 14:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVector<winrt::hstring>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::Class_Windows_Foundation_Collections_IIterable_1_HSTRING_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_HSTRING__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_HSTRING__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_HSTRING__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_HSTRING_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable__dispatchProperties[] =
{
    L"first",
    L"hasKey",
    L"lookup",
    L"size",
    L"split"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::s_dispatchIds[5] =
{
    4,
    2,
    1,
    6,
    3
};

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Split
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                2, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Split(
                                RefConverter<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"first")
                                ) // Out, Ref
                                ,
                                RefConverter<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"second")
                                ) // Out, Ref
                    );

                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::Class_Windows_Foundation_Collections_IIterator_1_HSTRING_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_HSTRING__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_HSTRING__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_HSTRING__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_HSTRING_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::hstring>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::hstring>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__dispatchProperties[] =
{
    L"key",
    L"value"
};
DispatchProperties Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::s_dispatchIds[2] =
{
    2,
    3
};

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for Key
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Key();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for Value
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Value();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IPropertySet::Class_Windows_Foundation_Collections_IPropertySet(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 14)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IPropertySet_dispatchProperties[] =
{
    L"clear",
    L"first",
    L"getView",
    L"hasKey",
    L"insert",
    L"lookup",
    L"remove"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IPropertySet::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IPropertySet_dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IPropertySet::s_dispatchIds[7] =
{
    6,
    7,
    3,
    2,
    4,
    1,
    5
};

HRESULT Class_Windows_Foundation_Collections_IPropertySet::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IPropertySet_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IPropertySet::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IPropertySet::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 7))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IPropertySet::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IPropertySet::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method Insert
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Insert(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Foundation::IInspectable>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Insert
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Insert(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Foundation::IInspectable>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Remove
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Remove(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Remove
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Remove(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_User_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::System::User>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::System::User>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 14)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable__dispatchProperties[] =
{
    L"clear",
    L"first",
    L"getView",
    L"hasKey",
    L"insert",
    L"lookup",
    L"remove"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::s_dispatchIds[7] =
{
    6,
    7,
    3,
    2,
    4,
    1,
    5
};

HRESULT Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 7))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (FAILED(hr) && wcscmp(names[0], L"addEventListener") == 0)
        {
            *dispId = 11;
            hr = S_OK;
        }
        else if (FAILED(hr) && wcscmp(names[0], L"removeEventListener") == 0)
        {
            *dispId = 11 + 1;
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IObservableMap_2_HSTRING_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method Insert
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Insert(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Foundation::IInspectable>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Remove
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Remove(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                case 11:
                    // addEventListener(name, callback) Invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"mapChanged") == 0)
                            {
                                winrt::Windows::Foundation::Collections::IObservableMap<winrt::hstring, winrt::Windows::Foundation::IInspectable> innerObject = m_innerObject
                                    .as<winrt::Windows::Foundation::Collections::IObservableMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationMapChanged.find(callback.get()) ==
                                        m_eventRegistrationMapChanged.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.MapChanged(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& event) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant eventAsVARIANT(
                                                    Converter<decltype(event), VARIANT>(dispatchAdapter).
                                                        Convert(event));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { eventAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"mapChanged", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationMapChanged[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else
                            {
                                // AddEventListener silently ignores subscriptions to events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                case 11 + 1:
                    // removeEventListener(name, callback) invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"mapChanged") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationMapChanged.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else
                            {
                                // RemoveEventListener silently ignores unregistering events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 15)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__dispatchProperties[] =
{
    L"clear",
    L"first",
    L"getView",
    L"hasKey",
    L"insert",
    L"lookup",
    L"remove",
    L"size"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::s_dispatchIds[8] =
{
    6,
    7,
    3,
    2,
    4,
    1,
    5,
    9
};

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 8))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method Insert
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Insert(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Foundation::IInspectable>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Remove
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Remove(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 9:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_User_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_User_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::System::User>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::User>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::StorageFile>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageFile>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::StorageFolder>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageFolder>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::IStorageItem>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::IStorageItem>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_IWwwFormUrlDecoderEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_MapChangedEventHandler_2_HSTRING_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_System_UserWatcherUpdateKind_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::System::UserWatcherUpdateKind>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::System::UserWatcherUpdateKind>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::UserWatcherUpdateKind>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFile_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFile_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageFile>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageFolder_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageFolder_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageFolder>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_IStorageItem_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_IStorageItem_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Storage::IStorageItem>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 15)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties[] =
{
    L"clear",
    L"first",
    L"getView",
    L"hasKey",
    L"insert",
    L"lookup",
    L"remove",
    L"size"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchIds[8] =
{
    6,
    7,
    3,
    2,
    4,
    1,
    5,
    9
};

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 8))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMap_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method Insert
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Insert(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Remove
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                    innerObject.Remove(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 9:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 20)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry__dispatchProperties[] =
{
    L"append",
    L"clear",
    L"first",
    L"getAt",
    L"getMany",
    L"getView",
    L"indexOf",
    L"insertAt",
    L"removeAt",
    L"removeAtEnd",
    L"replaceAll",
    L"setAt",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::s_dispatchIds[13] =
{
    7,
    9,
    12,
    1,
    10,
    2,
    3,
    5,
    6,
    8,
    11,
    4,
    14
};

HRESULT Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 13))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVector_1_Windows_Storage_Search_SortEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetView
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetView(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::Search::SortEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method SetAt
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.SetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Search::SortEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method InsertAt
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.InsertAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Search::SortEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method RemoveAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.RemoveAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method Append
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.Append(
                                Converter<VARIANT, winrt::Windows::Storage::Search::SortEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for method RemoveAtEnd
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.RemoveAtEnd(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for method Clear
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.Clear(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::Search::SortEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for method ReplaceAll
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                    innerObject.ReplaceAll(
                                Converter<VARIANT, winrt::array_view<winrt::Windows::Storage::Search::SortEntry>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 14:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Search::SortEntry>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_System_UserWatcherUpdateKind_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_System_UserWatcherUpdateKind_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::System::UserWatcherUpdateKind>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::System::UserWatcherUpdateKind>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Data::Text::TextSegment>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Data::Text::TextSegment>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties[] =
{
    L"first",
    L"hasKey",
    L"lookup",
    L"size",
    L"split"
    ,
        L"getAllKeyNames"
};
DispatchProperties Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchIds[5] =
{
    4,
    2,
    1,
    6,
    3
};

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IMapView_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Lookup
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Lookup(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method HasKey
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.HasKey(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Split
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                2, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                    innerObject.Split(
                                RefConverter<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"first")
                                ) // Out, Ref
                                ,
                                RefConverter<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"second")
                                ) // Out, Ref
                    );

                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment____dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_SortEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::Search::SortEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::Search::SortEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::Search::SortEntry>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_Search_SortEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_Search_SortEntry_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Storage::Search::SortEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::Search::SortEntry>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Data_Text_TextSegment_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Data_Text_TextSegment_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Data::Text::TextSegment>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Data::Text::TextSegment>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties[] =
{
    L"key",
    L"value"
};
DispatchProperties Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::s_dispatchIds[2] =
{
    2,
    3
};

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IKeyValuePair_2_HSTRING_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for Key
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Key();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for Value
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Data::Text::TextSegment>>>();
                            auto resultAsWinRT = innerObject.Value();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::s_dispatchIds[5] =
{
    4,
    1,
    3,
    2,
    6
};

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Storage::StorageLibraryChange>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageLibraryChange>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange__dispatchProperties[] =
{
    L"first"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterable_1_Windows_Storage_StorageLibraryChange_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange__dispatchProperties[] =
{
    L"current",
    L"getMany",
    L"hasCurrent",
    L"moveNext"
};
DispatchProperties Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::s_dispatchProperties = s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange__dispatchProperties;
const DISPID Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::s_dispatchIds[4] =
{
    4,
    2,
    5,
    1
};

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Collections_IIterator_1_Windows_Storage_StorageLibraryChange_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method MoveNext
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.MoveNext(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetMany
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                RefConverter<winrt::array_view<winrt::Windows::Storage::StorageLibraryChange>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[1 - 0 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Current
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.Current();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for HasCurrent
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterator<winrt::Windows::Storage::StorageLibraryChange>>();
                            auto resultAsWinRT = innerObject.HasCurrent();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}


