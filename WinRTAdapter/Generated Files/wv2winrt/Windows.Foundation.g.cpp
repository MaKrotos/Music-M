// WARNING: Please don't edit this file. It was generated by wv2winrt v1.0.0.0
#include "pch.h"

#include "wv2winrt/asyncdispatch.h"
#include "wv2winrt/converter.h"
#include "wv2winrt/eventargsdispatch.h"
#include "wv2winrt/implicitstructs.g.h"
#include "wv2winrt/main.h"
#include "wv2winrt/returnaggregator.h"
#include "wv2winrt/uniquevariant.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.Collections.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "wv2winrt/Windows.Foundation.g.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/Windows.Storage.Streams.h"
#include "winrt/Windows.System.h"
#include "winrt/Windows.Storage.h"
#include "winrt/Windows.Storage.FileProperties.h"
#include "winrt/Windows.Storage.Search.h"


namespace wv2winrt_impl
{
Namespace_Windows_Foundation::Namespace_Windows_Foundation(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Namespace_Windows_Foundation_dispatchProperties[] =
{
    L"AsyncStatus",
    L"Collections",
    L"DateTime",
    L"HResult",
    L"Point",
    L"PropertyType",
    L"Rect",
    L"Size",
    L"TimeSpan",
    L"Uri",
    L"WwwFormUrlDecoder"
};
DispatchProperties Namespace_Windows_Foundation::s_dispatchProperties = s_Namespace_Windows_Foundation_dispatchProperties;

const DISPID Namespace_Windows_Foundation::s_dispatchIds[11] =
{
    135,
    36,
    107,
    133,
    320,
    337,
    324,
    322,
    287,
    101,
    165
};

HRESULT Namespace_Windows_Foundation::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Namespace_Windows_Foundation_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Namespace_Windows_Foundation::GetIDsOfNames(REFIID riid,
                                                  LPOLESTR* names,
                                                  unsigned int namesCount,
                                                  LCID localeId,
                                                  DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 11))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Namespace_Windows_Foundation::Invoke(DISPID dispId,
                                           REFIID riid,
                                           LCID localeId,
                                           WORD flags,
                                           DISPPARAMS* dispParams,
                                           VARIANT* result,
                                           EXCEPINFO* excepInfo,
                                           UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                winrt::com_ptr<IDispatch> dispatch;
#pragma warning( push )
#pragma warning( disable: 4065 )
                switch (dispId)
                {
                    case 36:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Foundation.Collections", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 135:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Foundation.AsyncStatus", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 337:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Foundation.PropertyType", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 101:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Foundation.Uri", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 165:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Foundation.WwwFormUrlDecoder", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }

                    default:
                        hr = DISP_E_MEMBERNOTFOUND;
                        break;
                }
#pragma warning( pop )

                if (SUCCEEDED(hr))
                {
                    // Copy dispatch into output result
                    VARIANT dispatchAsVariant;
                    dispatchAsVariant.vt = VT_DISPATCH;
                    dispatchAsVariant.pdispVal = dispatch.detach();
                    *result = dispatchAsVariant;
                }
            }
        }
        else if (flags == DISPATCH_METHOD || flags == 0)
        {
            switch (dispId)
            {
                case 107:
                {
                    // Invoke for Windows.Foundation.DateTime c'tor
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::TimeSpan duration{ Converter<VARIANT, int64_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)) };
                            winrt::Windows::Foundation::DateTime resultAsWinRT{ duration };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 133:
                {
                    // Invoke for Windows.Foundation.HResult c'tor
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::hresult resultAsWinRT{ Converter<VARIANT, int32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 1]) };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 287:
                {
                    // Invoke for Windows.Foundation.TimeSpan c'tor
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::TimeSpan resultAsWinRT{ Converter<VARIANT, int64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 1]) };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 320:
                {
                    // Invoke for Windows.Foundation.Point c'tor
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::Point resultAsWinRT{ Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1]),
                Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 2]) };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 322:
                {
                    // Invoke for Windows.Foundation.Size c'tor
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::Size resultAsWinRT{ Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1]),
                Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 2]) };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 324:
                {
                    // Invoke for Windows.Foundation.Rect c'tor
                    if (4 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::Rect resultAsWinRT{ Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[4 - 1]),
                Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[4 - 2]),
                Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[4 - 3]),
                Converter<VARIANT, float>(m_dispatchAdapter).Convert(dispParams->rgvarg[4 - 4]) };
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_Foundation_AsyncStatus::Enum_Windows_Foundation_AsyncStatus(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_Foundation_AsyncStatus_dispatchProperties[] =
{
    L"canceled",
    L"completed",
    L"error",
    L"started"
};
DispatchProperties Enum_Windows_Foundation_AsyncStatus::s_dispatchProperties = s_Enum_Windows_Foundation_AsyncStatus_dispatchProperties;

const DISPID Enum_Windows_Foundation_AsyncStatus::s_dispatchIds[4] =
{
    1,
    2,
    3,
    4
};

HRESULT Enum_Windows_Foundation_AsyncStatus::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_Foundation_AsyncStatus::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(0),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_Foundation_AsyncStatus::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_Foundation_AsyncStatus_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_Foundation_PropertyType::Enum_Windows_Foundation_PropertyType(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_Foundation_PropertyType_dispatchProperties[] =
{
    L"boolean",
    L"booleanArray",
    L"char16",
    L"char16Array",
    L"dateTime",
    L"dateTimeArray",
    L"double",
    L"doubleArray",
    L"empty",
    L"guid",
    L"guidArray",
    L"inspectable",
    L"inspectableArray",
    L"int16",
    L"int16Array",
    L"int32",
    L"int32Array",
    L"int64",
    L"int64Array",
    L"otherType",
    L"otherTypeArray",
    L"point",
    L"pointArray",
    L"rect",
    L"rectArray",
    L"single",
    L"singleArray",
    L"size",
    L"sizeArray",
    L"string",
    L"stringArray",
    L"timeSpan",
    L"timeSpanArray",
    L"uint16",
    L"uint16Array",
    L"uint32",
    L"uint32Array",
    L"uint64",
    L"uint64Array",
    L"uint8",
    L"uint8Array"
};
DispatchProperties Enum_Windows_Foundation_PropertyType::s_dispatchProperties = s_Enum_Windows_Foundation_PropertyType_dispatchProperties;

const DISPID Enum_Windows_Foundation_PropertyType::s_dispatchIds[41] =
{
    12,
    32,
    11,
    31,
    15,
    35,
    10,
    30,
    1,
    17,
    37,
    14,
    34,
    3,
    23,
    5,
    25,
    7,
    27,
    21,
    41,
    18,
    38,
    20,
    40,
    9,
    29,
    19,
    39,
    13,
    33,
    16,
    36,
    4,
    24,
    6,
    26,
    8,
    28,
    2,
    22
};

HRESULT Enum_Windows_Foundation_PropertyType::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 41))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_Foundation_PropertyType::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        5,
                        static_cast<UINT32>(4),
                        false
                    },
                    {
                        6,
                        static_cast<UINT32>(5),
                        false
                    },
                    {
                        7,
                        static_cast<UINT32>(6),
                        false
                    },
                    {
                        8,
                        static_cast<UINT32>(7),
                        false
                    },
                    {
                        9,
                        static_cast<UINT32>(8),
                        false
                    },
                    {
                        10,
                        static_cast<UINT32>(9),
                        false
                    },
                    {
                        11,
                        static_cast<UINT32>(10),
                        false
                    },
                    {
                        12,
                        static_cast<UINT32>(11),
                        false
                    },
                    {
                        13,
                        static_cast<UINT32>(12),
                        false
                    },
                    {
                        14,
                        static_cast<UINT32>(13),
                        false
                    },
                    {
                        15,
                        static_cast<UINT32>(14),
                        false
                    },
                    {
                        16,
                        static_cast<UINT32>(15),
                        false
                    },
                    {
                        17,
                        static_cast<UINT32>(16),
                        false
                    },
                    {
                        18,
                        static_cast<UINT32>(17),
                        false
                    },
                    {
                        19,
                        static_cast<UINT32>(18),
                        false
                    },
                    {
                        20,
                        static_cast<UINT32>(19),
                        false
                    },
                    {
                        21,
                        static_cast<UINT32>(20),
                        false
                    },
                    {
                        22,
                        static_cast<UINT32>(1025),
                        false
                    },
                    {
                        23,
                        static_cast<UINT32>(1026),
                        false
                    },
                    {
                        24,
                        static_cast<UINT32>(1027),
                        false
                    },
                    {
                        25,
                        static_cast<UINT32>(1028),
                        false
                    },
                    {
                        26,
                        static_cast<UINT32>(1029),
                        false
                    },
                    {
                        27,
                        static_cast<UINT32>(1030),
                        false
                    },
                    {
                        28,
                        static_cast<UINT32>(1031),
                        false
                    },
                    {
                        29,
                        static_cast<UINT32>(1032),
                        false
                    },
                    {
                        30,
                        static_cast<UINT32>(1033),
                        false
                    },
                    {
                        31,
                        static_cast<UINT32>(1034),
                        false
                    },
                    {
                        32,
                        static_cast<UINT32>(1035),
                        false
                    },
                    {
                        33,
                        static_cast<UINT32>(1036),
                        false
                    },
                    {
                        34,
                        static_cast<UINT32>(1037),
                        false
                    },
                    {
                        35,
                        static_cast<UINT32>(1038),
                        false
                    },
                    {
                        36,
                        static_cast<UINT32>(1039),
                        false
                    },
                    {
                        37,
                        static_cast<UINT32>(1040),
                        false
                    },
                    {
                        38,
                        static_cast<UINT32>(1041),
                        false
                    },
                    {
                        39,
                        static_cast<UINT32>(1042),
                        false
                    },
                    {
                        40,
                        static_cast<UINT32>(1043),
                        false
                    },
                    {
                        41,
                        static_cast<UINT32>(1044),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_Foundation_PropertyType::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_Foundation_PropertyType_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_DateTime::Struct_Windows_Foundation_DateTime(winrt::Windows::Foundation::DateTime innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_DateTime_dispatchProperties[] =
{
    L"universalTime"
};
DispatchProperties Struct_Windows_Foundation_DateTime::s_dispatchProperties = s_Struct_Windows_Foundation_DateTime_dispatchProperties;

const DISPID Struct_Windows_Foundation_DateTime::s_dispatchIds[1] =
{
    1
};

HRESULT Struct_Windows_Foundation_DateTime::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_DateTime::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for UniversalTime
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.time_since_epoch().count();
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::TimeSpan ticks{ Converter<VARIANT, int64_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)) };
                            winrt::Windows::Foundation::DateTime updated { ticks };
                            m_innerObject = updated;

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_DateTime::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_DateTime::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_DateTime_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_HResult::Struct_Windows_Foundation_HResult(winrt::hresult innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_HResult_dispatchProperties[] =
{
    L"value"
};
DispatchProperties Struct_Windows_Foundation_HResult::s_dispatchProperties = s_Struct_Windows_Foundation_HResult_dispatchProperties;

const DISPID Struct_Windows_Foundation_HResult::s_dispatchIds[1] =
{
    1
};

HRESULT Struct_Windows_Foundation_HResult::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_HResult::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for Value
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.value;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.value = Converter<VARIANT, int32_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_HResult::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_HResult::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_HResult_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_TimeSpan::Struct_Windows_Foundation_TimeSpan(winrt::Windows::Foundation::TimeSpan innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_TimeSpan_dispatchProperties[] =
{
    L"duration"
};
DispatchProperties Struct_Windows_Foundation_TimeSpan::s_dispatchProperties = s_Struct_Windows_Foundation_TimeSpan_dispatchProperties;

const DISPID Struct_Windows_Foundation_TimeSpan::s_dispatchIds[1] =
{
    1
};

HRESULT Struct_Windows_Foundation_TimeSpan::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_TimeSpan::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for Duration
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.count();
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::TimeSpan updated{ Converter<VARIANT, int64_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)) };
                            m_innerObject = updated;

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_TimeSpan::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_TimeSpan::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_TimeSpan_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_Point::Struct_Windows_Foundation_Point(winrt::Windows::Foundation::Point innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_Point_dispatchProperties[] =
{
    L"x",
    L"y"
};
DispatchProperties Struct_Windows_Foundation_Point::s_dispatchProperties = s_Struct_Windows_Foundation_Point_dispatchProperties;

const DISPID Struct_Windows_Foundation_Point::s_dispatchIds[2] =
{
    1,
    2
};

HRESULT Struct_Windows_Foundation_Point::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Point::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for X
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.X;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.X = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 2:
                    // Invoke for Y
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Y;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Y = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Point::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_Point::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_Point_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_Size::Struct_Windows_Foundation_Size(winrt::Windows::Foundation::Size innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_Size_dispatchProperties[] =
{
    L"height",
    L"width"
};
DispatchProperties Struct_Windows_Foundation_Size::s_dispatchProperties = s_Struct_Windows_Foundation_Size_dispatchProperties;

const DISPID Struct_Windows_Foundation_Size::s_dispatchIds[2] =
{
    2,
    1
};

HRESULT Struct_Windows_Foundation_Size::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Size::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for Width
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Width;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Width = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 2:
                    // Invoke for Height
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Height;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Height = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Size::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_Size::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_Size_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

namespace wv2winrt_impl
{
Struct_Windows_Foundation_Rect::Struct_Windows_Foundation_Rect(winrt::Windows::Foundation::Rect innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_innerObject(innerObject), m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Struct_Windows_Foundation_Rect_dispatchProperties[] =
{
    L"height",
    L"width",
    L"x",
    L"y"
};
DispatchProperties Struct_Windows_Foundation_Rect::s_dispatchProperties = s_Struct_Windows_Foundation_Rect_dispatchProperties;

const DISPID Struct_Windows_Foundation_Rect::s_dispatchIds[4] =
{
    4,
    3,
    1,
    2
};

HRESULT Struct_Windows_Foundation_Rect::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Rect::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 1:
                    // Invoke for X
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.X;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.X = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 2:
                    // Invoke for Y
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Y;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Y = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 3:
                    // Invoke for Width
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Width;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Width = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 4:
                    // Invoke for Height
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = m_innerObject.Height;
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            m_innerObject.Height = Converter<VARIANT, float>(m_dispatchAdapter).Convert(*(dispParams->rgvarg));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

HRESULT Struct_Windows_Foundation_Rect::GetInnerObject(IUnknown** object)
{
    auto boxed = winrt::box_value(m_innerObject);
    *object = boxed.as<IUnknown>().detach();

    return S_OK;
}

HRESULT Struct_Windows_Foundation_Rect::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Struct_Windows_Foundation_Rect_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

} // namespace wv2winrt_impl

#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_bool_::Class_Windows_Foundation_IAsyncOperation_1_bool_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_bool__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_bool_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_bool__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_bool_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_bool_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_bool__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_bool_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_bool_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_bool_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_bool_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<bool>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<bool>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<bool>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<bool>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::Class_Windows_Foundation_IAsyncOperation_1_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_IInspectable__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_IInspectable__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_IInspectable__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::IInspectable>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::IInspectable>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::IInspectable>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IPropertySet>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IPropertySet>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IPropertySet>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IPropertySet>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_System_UserAgeConsentResult_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::System::UserAgeConsentResult>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::System::UserAgeConsentResult>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::System::UserAgeConsentResult>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::System::UserAgeConsentResult>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::System::User>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_bool_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncInfo::Class_Windows_Foundation_IAsyncInfo(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncInfo_dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"errorCode",
    L"id",
    L"status"
};
DispatchProperties Class_Windows_Foundation_IAsyncInfo::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncInfo_dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncInfo::s_dispatchIds[5] =
{
    1,
    2,
    4,
    5,
    6
};

HRESULT Class_Windows_Foundation_IAsyncInfo::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncInfo_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncInfo::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncInfo::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncInfo::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncInfo::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for ErrorCode
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                            auto resultAsWinRT = innerObject.ErrorCode();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for Id
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                            auto resultAsWinRT = innerObject.Id();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for Status
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                            auto resultAsWinRT = innerObject.Status();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStream>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::Streams::IRandomAccessStream>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageStreamTransaction>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::StorageStreamTransaction>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFile_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::StorageFile>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncAction::Class_Windows_Foundation_IAsyncAction(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncAction_dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncAction::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncAction_dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncAction::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncAction::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncAction_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncAction::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncAction::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncAction::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncAction::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncAction>();
                    innerObject.GetResults(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncAction>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncAction>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncActionCompletedHandler>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IInputStream>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::Streams::IInputStream>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::BasicProperties>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::BasicProperties>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::StorageItemThumbnail>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageFolder_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFolder>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::StorageFolder>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IUriRuntimeClassFactory::Class_Windows_Foundation_IUriRuntimeClassFactory(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IUriRuntimeClassFactory_dispatchProperties[] =
{
    L"createUri",
    L"createWithRelativeUri"
};
DispatchProperties Class_Windows_Foundation_IUriRuntimeClassFactory::s_dispatchProperties = s_Class_Windows_Foundation_IUriRuntimeClassFactory_dispatchProperties;
const DISPID Class_Windows_Foundation_IUriRuntimeClassFactory::s_dispatchIds[2] =
{
    1,
    2
};

HRESULT Class_Windows_Foundation_IUriRuntimeClassFactory::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IUriRuntimeClassFactory_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassFactory::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassFactory::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassFactory::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassFactory::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method CreateUri
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClassFactory>();
                            auto resultAsWinRT = innerObject.CreateUri(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method CreateWithRelativeUri
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClassFactory>();
                            auto resultAsWinRT = innerObject.CreateWithRelativeUri(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_Uri::Class_Windows_Foundation_Uri(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_Uri_dispatchProperties[] =
{
    L"absoluteCanonicalUri",
    L"absoluteUri",
    L"combineUri",
    L"displayIri",
    L"displayUri",
    L"domain",
    L"equals",
    L"extension",
    L"fragment",
    L"host",
    L"password",
    L"path",
    L"port",
    L"query",
    L"queryParsed",
    L"rawUri",
    L"schemeName",
    L"suspicious",
    L"toString",
    L"userName"
};
DispatchProperties Class_Windows_Foundation_Uri::s_dispatchProperties = s_Class_Windows_Foundation_Uri_dispatchProperties;
const DISPID Class_Windows_Foundation_Uri::s_dispatchIds[20] =
{
    22,
    7,
    2,
    23,
    8,
    9,
    1,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    3,
    21
};

HRESULT Class_Windows_Foundation_Uri::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_Uri_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_Uri::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_Uri::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 20))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_Uri::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_Uri::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Equals
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Equals(
                                Converter<VARIANT, winrt::Windows::Foundation::Uri>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method CombineUri
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.CombineUri(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method ToString
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IStringable>();
                            auto resultAsWinRT = innerObject.ToString(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 7:
                {
                    // Invoke for AbsoluteUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.AbsoluteUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for DisplayUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.DisplayUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for Domain
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Domain();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for Extension
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Extension();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for Fragment
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Fragment();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for Host
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Host();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 13:
                {
                    // Invoke for Password
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Password();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 14:
                {
                    // Invoke for Path
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Path();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 15:
                {
                    // Invoke for Port
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Port();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 16:
                {
                    // Invoke for Query
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Query();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 17:
                {
                    // Invoke for QueryParsed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.QueryParsed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 18:
                {
                    // Invoke for RawUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.RawUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 19:
                {
                    // Invoke for SchemeName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.SchemeName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 20:
                {
                    // Invoke for Suspicious
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.Suspicious();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 21:
                {
                    // Invoke for UserName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.UserName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 22:
                {
                    // Invoke for AbsoluteCanonicalUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.AbsoluteCanonicalUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 23:
                {
                    // Invoke for DisplayIri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Uri>();
                            auto resultAsWinRT = innerObject.DisplayIri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_System_UserAgeConsentResult_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_System_UserWatcher_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_IStorageItem_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::IStorageItem>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::IStorageItem>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFile>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageFolder>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncActionCompletedHandler::Class_Windows_Foundation_AsyncActionCompletedHandler(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncActionCompletedHandler::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncActionCompletedHandler::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncActionCompletedHandler::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncActionCompletedHandler::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncActionCompletedHandler::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncActionCompletedHandler::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory_dispatchProperties[] =
{
    L"createWwwFormUrlDecoder"
};
DispatchProperties Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::s_dispatchProperties = s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory_dispatchProperties;
const DISPID Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClassFactory::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method CreateWwwFormUrlDecoder
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IWwwFormUrlDecoderRuntimeClassFactory>();
                            auto resultAsWinRT = innerObject.CreateWwwFormUrlDecoder(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_WwwFormUrlDecoder::Class_Windows_Foundation_WwwFormUrlDecoder(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 13)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_WwwFormUrlDecoder_dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getFirstValueByName",
    L"getMany",
    L"indexOf",
    L"size"
};
DispatchProperties Class_Windows_Foundation_WwwFormUrlDecoder::s_dispatchProperties = s_Class_Windows_Foundation_WwwFormUrlDecoder_dispatchProperties;
const DISPID Class_Windows_Foundation_WwwFormUrlDecoder::s_dispatchIds[6] =
{
    5,
    2,
    1,
    4,
    3,
    7
};

HRESULT Class_Windows_Foundation_WwwFormUrlDecoder::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_WwwFormUrlDecoder_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_WwwFormUrlDecoder::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_WwwFormUrlDecoder::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 6))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_WwwFormUrlDecoder::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_WwwFormUrlDecoder::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetFirstValueByName
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IWwwFormUrlDecoderRuntimeClass>();
                            auto resultAsWinRT = innerObject.GetFirstValueByName(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 7:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::WwwFormUrlDecoder>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IUriRuntimeClass::Class_Windows_Foundation_IUriRuntimeClass(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IUriRuntimeClass_dispatchProperties[] =
{
    L"absoluteUri",
    L"combineUri",
    L"displayUri",
    L"domain",
    L"equals",
    L"extension",
    L"fragment",
    L"host",
    L"password",
    L"path",
    L"port",
    L"query",
    L"queryParsed",
    L"rawUri",
    L"schemeName",
    L"suspicious",
    L"userName"
};
DispatchProperties Class_Windows_Foundation_IUriRuntimeClass::s_dispatchProperties = s_Class_Windows_Foundation_IUriRuntimeClass_dispatchProperties;
const DISPID Class_Windows_Foundation_IUriRuntimeClass::s_dispatchIds[17] =
{
    4,
    2,
    5,
    6,
    1,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18
};

HRESULT Class_Windows_Foundation_IUriRuntimeClass::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IUriRuntimeClass_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClass::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClass::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 17))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClass::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClass::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Equals
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Equals(
                                Converter<VARIANT, winrt::Windows::Foundation::Uri>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method CombineUri
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.CombineUri(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for AbsoluteUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.AbsoluteUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for DisplayUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.DisplayUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for Domain
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Domain();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for Extension
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Extension();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for Fragment
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Fragment();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for Host
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Host();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for Password
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Password();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for Path
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Path();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for Port
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Port();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 13:
                {
                    // Invoke for Query
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Query();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 14:
                {
                    // Invoke for QueryParsed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.QueryParsed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 15:
                {
                    // Invoke for RawUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.RawUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 16:
                {
                    // Invoke for SchemeName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.SchemeName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 17:
                {
                    // Invoke for Suspicious
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.Suspicious();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 18:
                {
                    // Invoke for UserName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClass>();
                            auto resultAsWinRT = innerObject.UserName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri_dispatchProperties[] =
{
    L"absoluteCanonicalUri",
    L"displayIri"
};
DispatchProperties Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::s_dispatchProperties = s_Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri_dispatchProperties;
const DISPID Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::s_dispatchIds[2] =
{
    2,
    3
};

HRESULT Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IUriRuntimeClassWithAbsoluteCanonicalUri::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for AbsoluteCanonicalUri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClassWithAbsoluteCanonicalUri>();
                            auto resultAsWinRT = innerObject.AbsoluteCanonicalUri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for DisplayIri
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IUriRuntimeClassWithAbsoluteCanonicalUri>();
                            auto resultAsWinRT = innerObject.DisplayIri();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IStringable::Class_Windows_Foundation_IStringable(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IStringable_dispatchProperties[] =
{
    L"toString"
};
DispatchProperties Class_Windows_Foundation_IStringable::s_dispatchProperties = s_Class_Windows_Foundation_IStringable_dispatchProperties;
const DISPID Class_Windows_Foundation_IStringable::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_IStringable::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IStringable_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IStringable::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IStringable::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IStringable::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IStringable::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method ToString
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IStringable>();
                            auto resultAsWinRT = innerObject.ToString(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::MusicProperties>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::MusicProperties>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::MusicProperties>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::MusicProperties>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::VideoProperties>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::VideoProperties>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::VideoProperties>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::VideoProperties>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::ImageProperties>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::ImageProperties>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::ImageProperties>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::ImageProperties>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::DocumentProperties>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::DocumentProperties>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::FileProperties::DocumentProperties>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::FileProperties::DocumentProperties>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults",
    L"progress"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::s_dispatchIds[5] =
{
    2,
    3,
    6,
    1,
    5
};

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Progress
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>();
                            auto resultAsWinRT = innerObject.Progress();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>();
                            innerObject.Progress(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationProgressHandler<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<winrt::Windows::Storage::Streams::IBuffer, uint32_t>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults",
    L"progress"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::s_dispatchIds[5] =
{
    2,
    3,
    6,
    1,
    5
};

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperationWithProgress_2_uint32_t_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Progress
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t>>();
                            auto resultAsWinRT = innerObject.Progress();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t>>();
                            innerObject.Progress(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationProgressHandler<uint32_t, uint32_t>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperationWithProgress<uint32_t, uint32_t>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<uint32_t, uint32_t>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IClosable::Class_Windows_Foundation_IClosable(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IClosable_dispatchProperties[] =
{
    L"close"
};
DispatchProperties Class_Windows_Foundation_IClosable::s_dispatchProperties = s_Class_Windows_Foundation_IClosable_dispatchProperties;
const DISPID Class_Windows_Foundation_IClosable::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Foundation_IClosable::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IClosable_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IClosable::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IClosable::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IClosable::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IClosable::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Storage_Search_IndexedState_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Search::IndexedState>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Search::IndexedState>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Search::IndexedState>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Storage::Search::IndexedState>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IWwwFormUrlDecoderEntry::Class_Windows_Foundation_IWwwFormUrlDecoderEntry(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IWwwFormUrlDecoderEntry_dispatchProperties[] =
{
    L"name",
    L"value"
};
DispatchProperties Class_Windows_Foundation_IWwwFormUrlDecoderEntry::s_dispatchProperties = s_Class_Windows_Foundation_IWwwFormUrlDecoderEntry_dispatchProperties;
const DISPID Class_Windows_Foundation_IWwwFormUrlDecoderEntry::s_dispatchIds[2] =
{
    2,
    3
};

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderEntry::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IWwwFormUrlDecoderEntry_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderEntry::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderEntry::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderEntry::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderEntry::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for Name
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>();
                            auto resultAsWinRT = innerObject.Name();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for Value
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>();
                            auto resultAsWinRT = innerObject.Value();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
    , m_dispatchCollectionHelper(dispatchAdapter, 12)

{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass_dispatchProperties[] =
{
    L"first",
    L"getAt",
    L"getFirstValueByName",
    L"getMany",
    L"indexOf"
};
DispatchProperties Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::s_dispatchProperties = s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass_dispatchProperties;
const DISPID Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::s_dispatchIds[5] =
{
    2,
    3,
    1,
    5,
    4
};

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.GetIDsOfNames(
                names, dispId);
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IWwwFormUrlDecoderRuntimeClass::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetFirstValueByName
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IWwwFormUrlDecoderRuntimeClass>();
                            auto resultAsWinRT = innerObject.GetFirstValueByName(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method First
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.First(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetAt(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method IndexOf
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.IndexOf(
                                Converter<VARIANT, winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                                ,
                                RefConverter<uint32_t, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    returnAggregator->AddParameter(L"index")
                                ) // Out, Ref
                    );

                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method GetMany
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !false);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>>();
                            auto resultAsWinRT = innerObject.GetMany(
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>, VARIANT>(m_dispatchAdapter).ConvertInOut(dispParams->rgvarg[2 - 1 - 1],
                                    returnAggregator->AddParameter(L"items")
                                ) // Out
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"items") };
                            int indexesArr[] = { 1 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                            returnAggregator->SetReturnValue(
                                Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT));
                            result->vt = VT_DISPATCH;
                            returnAggregator.as<::IDispatch>().copy_to(&result->pdispVal);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
        if (hr == DISP_E_MEMBERNOTFOUND)
        {
            hr = m_dispatchCollectionHelper.Invoke(
                m_innerObject.as<
                    winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>
                >(),
                dispId,
                flags,
                dispParams,
                result);
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_HSTRING_IInspectable__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationProgressHandler_2_uint32_t_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationWithProgressCompletedHandler_2_uint32_t_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::Class_Windows_Foundation_IAsyncOperation_1_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_uint32_t__dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_uint32_t__dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_uint32_t__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<uint32_t>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<uint32_t>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<uint32_t>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_IInspectable_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IReference_1_double_::Class_Windows_Foundation_IReference_1_double_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IReference_1_double__dispatchProperties[] =
{
    L"getBoolean",
    L"getBooleanArray",
    L"getChar16",
    L"getChar16Array",
    L"getDateTime",
    L"getDateTimeArray",
    L"getDouble",
    L"getDoubleArray",
    L"getGuid",
    L"getGuidArray",
    L"getInspectableArray",
    L"getInt16",
    L"getInt16Array",
    L"getInt32",
    L"getInt32Array",
    L"getInt64",
    L"getInt64Array",
    L"getPoint",
    L"getPointArray",
    L"getRect",
    L"getRectArray",
    L"getSingle",
    L"getSingleArray",
    L"getSize",
    L"getSizeArray",
    L"getString",
    L"getStringArray",
    L"getTimeSpan",
    L"getTimeSpanArray",
    L"getUInt16",
    L"getUInt16Array",
    L"getUInt32",
    L"getUInt32Array",
    L"getUInt64",
    L"getUInt64Array",
    L"getUInt8",
    L"getUInt8Array",
    L"value"
};
DispatchProperties Class_Windows_Foundation_IReference_1_double_::s_dispatchProperties = s_Class_Windows_Foundation_IReference_1_double__dispatchProperties;
const DISPID Class_Windows_Foundation_IReference_1_double_::s_dispatchIds[38] =
{
    11,
    29,
    10,
    28,
    14,
    33,
    9,
    27,
    13,
    32,
    31,
    2,
    20,
    4,
    22,
    6,
    24,
    16,
    35,
    18,
    37,
    8,
    26,
    17,
    36,
    12,
    30,
    15,
    34,
    3,
    21,
    5,
    23,
    7,
    25,
    1,
    19,
    39
};

HRESULT Class_Windows_Foundation_IReference_1_double_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IReference_1_double__dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IReference_1_double_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IReference_1_double_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 38))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IReference_1_double_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IReference_1_double_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetUInt8
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt8(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetInt16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetUInt16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method GetInt32
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt32(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method GetUInt32
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt32(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method GetInt64
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt64(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method GetUInt64
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt64(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for method GetSingle
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetSingle(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for method GetDouble
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetDouble(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for method GetChar16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetChar16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for method GetBoolean
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetBoolean(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for method GetString
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetString(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 13:
                {
                    // Invoke for method GetGuid
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetGuid(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 14:
                {
                    // Invoke for method GetDateTime
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetDateTime(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 15:
                {
                    // Invoke for method GetTimeSpan
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetTimeSpan(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 16:
                {
                    // Invoke for method GetPoint
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetPoint(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 17:
                {
                    // Invoke for method GetSize
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetSize(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 18:
                {
                    // Invoke for method GetRect
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetRect(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 19:
                {
                    // Invoke for method GetUInt8Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt8Array(
                                RefConverter<winrt::array_view<uint8_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 20:
                {
                    // Invoke for method GetInt16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt16Array(
                                RefConverter<winrt::array_view<int16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 21:
                {
                    // Invoke for method GetUInt16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt16Array(
                                RefConverter<winrt::array_view<uint16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 22:
                {
                    // Invoke for method GetInt32Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt32Array(
                                RefConverter<winrt::array_view<int32_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 23:
                {
                    // Invoke for method GetUInt32Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt32Array(
                                RefConverter<winrt::array_view<uint32_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 24:
                {
                    // Invoke for method GetInt64Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt64Array(
                                RefConverter<winrt::array_view<int64_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 25:
                {
                    // Invoke for method GetUInt64Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt64Array(
                                RefConverter<winrt::array_view<uint64_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 26:
                {
                    // Invoke for method GetSingleArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetSingleArray(
                                RefConverter<winrt::array_view<float>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 27:
                {
                    // Invoke for method GetDoubleArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetDoubleArray(
                                RefConverter<winrt::array_view<double>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 28:
                {
                    // Invoke for method GetChar16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetChar16Array(
                                RefConverter<winrt::array_view<char16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 29:
                {
                    // Invoke for method GetBooleanArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetBooleanArray(
                                RefConverter<winrt::array_view<bool>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 30:
                {
                    // Invoke for method GetStringArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetStringArray(
                                RefConverter<winrt::array_view<winrt::hstring>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 31:
                {
                    // Invoke for method GetInspectableArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInspectableArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IInspectable>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 32:
                {
                    // Invoke for method GetGuidArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetGuidArray(
                                RefConverter<winrt::array_view<winrt::guid>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 33:
                {
                    // Invoke for method GetDateTimeArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetDateTimeArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::DateTime>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 34:
                {
                    // Invoke for method GetTimeSpanArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetTimeSpanArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::TimeSpan>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 35:
                {
                    // Invoke for method GetPointArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetPointArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Point>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 36:
                {
                    // Invoke for method GetSizeArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetSizeArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Size>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 37:
                {
                    // Invoke for method GetRectArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetRectArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Rect>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 39:
                {
                    // Invoke for Value
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IReference<double>>();
                            auto resultAsWinRT = innerObject.Value();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_uint32_t_::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange___dispatchProperties[] =
{
    L"cancel",
    L"close",
    L"completed",
    L"getResults"
};
DispatchProperties Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::s_dispatchProperties = s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange___dispatchProperties;
const DISPID Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::s_dispatchIds[4] =
{
    2,
    3,
    5,
    1
};

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange___dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetResults
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>>();
                            auto resultAsWinRT = innerObject.GetResults(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Cancel
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Cancel(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncInfo>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for Completed
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>>();
                            auto resultAsWinRT = innerObject.Completed();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>>();
                            innerObject.Completed(
                                    Converter<VARIANT, winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::StorageLibraryChange>>>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_IPropertyValue::Class_Windows_Foundation_IPropertyValue(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Foundation_IPropertyValue_dispatchProperties[] =
{
    L"getBoolean",
    L"getBooleanArray",
    L"getChar16",
    L"getChar16Array",
    L"getDateTime",
    L"getDateTimeArray",
    L"getDouble",
    L"getDoubleArray",
    L"getGuid",
    L"getGuidArray",
    L"getInspectableArray",
    L"getInt16",
    L"getInt16Array",
    L"getInt32",
    L"getInt32Array",
    L"getInt64",
    L"getInt64Array",
    L"getPoint",
    L"getPointArray",
    L"getRect",
    L"getRectArray",
    L"getSingle",
    L"getSingleArray",
    L"getSize",
    L"getSizeArray",
    L"getString",
    L"getStringArray",
    L"getTimeSpan",
    L"getTimeSpanArray",
    L"getUInt16",
    L"getUInt16Array",
    L"getUInt32",
    L"getUInt32Array",
    L"getUInt64",
    L"getUInt64Array",
    L"getUInt8",
    L"getUInt8Array",
    L"isNumericScalar",
    L"type"
};
DispatchProperties Class_Windows_Foundation_IPropertyValue::s_dispatchProperties = s_Class_Windows_Foundation_IPropertyValue_dispatchProperties;
const DISPID Class_Windows_Foundation_IPropertyValue::s_dispatchIds[39] =
{
    11,
    29,
    10,
    28,
    14,
    33,
    9,
    27,
    13,
    32,
    31,
    2,
    20,
    4,
    22,
    6,
    24,
    16,
    35,
    18,
    37,
    8,
    26,
    17,
    36,
    12,
    30,
    15,
    34,
    3,
    21,
    5,
    23,
    7,
    25,
    1,
    19,
    39,
    40
};

HRESULT Class_Windows_Foundation_IPropertyValue::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Foundation_IPropertyValue_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_IPropertyValue::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_IPropertyValue::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 39))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Foundation_IPropertyValue::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_IPropertyValue::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetUInt8
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt8(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetInt16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetUInt16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method GetInt32
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt32(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method GetUInt32
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt32(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for method GetInt64
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetInt64(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for method GetUInt64
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetUInt64(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for method GetSingle
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetSingle(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for method GetDouble
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetDouble(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for method GetChar16
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetChar16(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for method GetBoolean
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetBoolean(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for method GetString
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetString(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 13:
                {
                    // Invoke for method GetGuid
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetGuid(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 14:
                {
                    // Invoke for method GetDateTime
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetDateTime(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 15:
                {
                    // Invoke for method GetTimeSpan
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetTimeSpan(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 16:
                {
                    // Invoke for method GetPoint
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetPoint(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 17:
                {
                    // Invoke for method GetSize
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetSize(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 18:
                {
                    // Invoke for method GetRect
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.GetRect(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 19:
                {
                    // Invoke for method GetUInt8Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt8Array(
                                RefConverter<winrt::array_view<uint8_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 20:
                {
                    // Invoke for method GetInt16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt16Array(
                                RefConverter<winrt::array_view<int16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 21:
                {
                    // Invoke for method GetUInt16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt16Array(
                                RefConverter<winrt::array_view<uint16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 22:
                {
                    // Invoke for method GetInt32Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt32Array(
                                RefConverter<winrt::array_view<int32_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 23:
                {
                    // Invoke for method GetUInt32Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt32Array(
                                RefConverter<winrt::array_view<uint32_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 24:
                {
                    // Invoke for method GetInt64Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInt64Array(
                                RefConverter<winrt::array_view<int64_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 25:
                {
                    // Invoke for method GetUInt64Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetUInt64Array(
                                RefConverter<winrt::array_view<uint64_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 26:
                {
                    // Invoke for method GetSingleArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetSingleArray(
                                RefConverter<winrt::array_view<float>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 27:
                {
                    // Invoke for method GetDoubleArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetDoubleArray(
                                RefConverter<winrt::array_view<double>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 28:
                {
                    // Invoke for method GetChar16Array
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetChar16Array(
                                RefConverter<winrt::array_view<char16_t>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 29:
                {
                    // Invoke for method GetBooleanArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetBooleanArray(
                                RefConverter<winrt::array_view<bool>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 30:
                {
                    // Invoke for method GetStringArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetStringArray(
                                RefConverter<winrt::array_view<winrt::hstring>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 31:
                {
                    // Invoke for method GetInspectableArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetInspectableArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::IInspectable>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 32:
                {
                    // Invoke for method GetGuidArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetGuidArray(
                                RefConverter<winrt::array_view<winrt::guid>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 33:
                {
                    // Invoke for method GetDateTimeArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetDateTimeArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::DateTime>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 34:
                {
                    // Invoke for method GetTimeSpanArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetTimeSpanArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::TimeSpan>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 35:
                {
                    // Invoke for method GetPointArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetPointArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Point>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 36:
                {
                    // Invoke for method GetSizeArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetSizeArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Size>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 37:
                {
                    // Invoke for method GetRectArray
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto returnAggregator = winrt::make_self<wv2winrt_impl::ReturnAggregator>(
                                1, !true);
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                    innerObject.GetRectArray(
                                RefConverter<winrt::array_view<winrt::Windows::Foundation::Rect>, VARIANT>(m_dispatchAdapter).ConvertOutRef(
                                    result
                                ) // Out, Ref
                    );


                            LPWSTR namesArr[] = { const_cast<LPWSTR>(L"value") };
                            int indexesArr[] = { 0 };
                            for (int i = 0; i < 1; i++) {
                                returnAggregator->AddOutArrayParameterInfoEntry(
                    		            namesArr[i], indexesArr[i]);
                            }


                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 39:
                {
                    // Invoke for IsNumericScalar
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.IsNumericScalar();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 40:
                {
                    // Invoke for Type
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IPropertyValue>();
                            auto resultAsWinRT = innerObject.Type();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

DispatchProperties Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::s_dispatchProperties = nullptr;
HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Foundation_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange__::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
Static_Class_Windows_Foundation_Uri::Static_Class_Windows_Foundation_Uri(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Static_Class_Windows_Foundation_Uri_dispatchProperties[] =
{
    L"escapeComponent",
    L"unescapeComponent"
};
DispatchProperties Static_Class_Windows_Foundation_Uri::s_dispatchProperties = s_Static_Class_Windows_Foundation_Uri_dispatchProperties;

const DISPID Static_Class_Windows_Foundation_Uri::s_dispatchIds[2] =
{
    2,
    1
};

HRESULT Static_Class_Windows_Foundation_Uri::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Static_Class_Windows_Foundation_Uri_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Static_Class_Windows_Foundation_Uri::GetIDsOfNames(
    REFIID riid,
    LPOLESTR* names,
    unsigned int namesCount,
    LCID localeId,
    DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Static_Class_Windows_Foundation_Uri::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                // 0 is the special dispId refering to the current object.
                // We use it here to mean you are invoking a constructor.
                case 0:
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::Uri resultAsWinRT {
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])

                                };

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::Uri resultAsWinRT {
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])

                                };

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 1:
                {
                    // Invoke for UnescapeComponent
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Foundation::Uri::UnescapeComponent(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for EscapeComponent
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Foundation::Uri::EscapeComponent(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
namespace wv2winrt_impl
{
Static_Class_Windows_Foundation_WwwFormUrlDecoder::Static_Class_Windows_Foundation_WwwFormUrlDecoder(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

DispatchProperties Static_Class_Windows_Foundation_WwwFormUrlDecoder::s_dispatchProperties = nullptr;

HRESULT Static_Class_Windows_Foundation_WwwFormUrlDecoder::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = 0;
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Static_Class_Windows_Foundation_WwwFormUrlDecoder::GetIDsOfNames(
    REFIID riid,
    LPOLESTR* names,
    unsigned int namesCount,
    LCID localeId,
    DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    return hr;
}

HRESULT Static_Class_Windows_Foundation_WwwFormUrlDecoder::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                // 0 is the special dispId refering to the current object.
                // We use it here to mean you are invoking a constructor.
                case 0:
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Foundation::WwwFormUrlDecoder resultAsWinRT {
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])

                                };

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}


