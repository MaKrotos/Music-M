// WARNING: Please don't edit this file. It was generated by wv2winrt v1.0.0.0
#include "pch.h"

#include "wv2winrt/asyncdispatch.h"
#include "wv2winrt/converter.h"
#include "wv2winrt/eventargsdispatch.h"
#include "wv2winrt/implicitstructs.g.h"
#include "wv2winrt/main.h"
#include "wv2winrt/returnaggregator.h"
#include "wv2winrt/uniquevariant.h"
#include "wv2winrt/Windows.Storage.Streams.g.h"
#include "wv2winrt/Windows.Storage.Streams.g.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Storage.Streams.h"


namespace wv2winrt_impl
{
Namespace_Windows_Storage_Streams::Namespace_Windows_Storage_Streams(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Namespace_Windows_Storage_Streams_dispatchProperties[] =
{
    L"InputStreamOptions"
};
DispatchProperties Namespace_Windows_Storage_Streams::s_dispatchProperties = s_Namespace_Windows_Storage_Streams_dispatchProperties;

const DISPID Namespace_Windows_Storage_Streams::s_dispatchIds[1] =
{
    189
};

HRESULT Namespace_Windows_Storage_Streams::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Namespace_Windows_Storage_Streams_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Namespace_Windows_Storage_Streams::GetIDsOfNames(REFIID riid,
                                                  LPOLESTR* names,
                                                  unsigned int namesCount,
                                                  LCID localeId,
                                                  DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Namespace_Windows_Storage_Streams::Invoke(DISPID dispId,
                                           REFIID riid,
                                           LCID localeId,
                                           WORD flags,
                                           DISPPARAMS* dispParams,
                                           VARIANT* result,
                                           EXCEPINFO* excepInfo,
                                           UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                winrt::com_ptr<IDispatch> dispatch;
#pragma warning( push )
#pragma warning( disable: 4065 )
                switch (dispId)
                {
                    case 189:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Storage.Streams.InputStreamOptions", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }

                    default:
                        hr = DISP_E_MEMBERNOTFOUND;
                        break;
                }
#pragma warning( pop )

                if (SUCCEEDED(hr))
                {
                    // Copy dispatch into output result
                    VARIANT dispatchAsVariant;
                    dispatchAsVariant.vt = VT_DISPATCH;
                    dispatchAsVariant.pdispVal = dispatch.detach();
                    *result = dispatchAsVariant;
                }
            }
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_Storage_Streams_InputStreamOptions::Enum_Windows_Storage_Streams_InputStreamOptions(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_Storage_Streams_InputStreamOptions_dispatchProperties[] =
{
    L"none",
    L"partial",
    L"readAhead"
};
DispatchProperties Enum_Windows_Storage_Streams_InputStreamOptions::s_dispatchProperties = s_Enum_Windows_Storage_Streams_InputStreamOptions_dispatchProperties;

const DISPID Enum_Windows_Storage_Streams_InputStreamOptions::s_dispatchIds[3] =
{
    1,
    2,
    3
};

HRESULT Enum_Windows_Storage_Streams_InputStreamOptions::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_Storage_Streams_InputStreamOptions::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0x0),
                        true
                    },
                    {
                        2,
                        static_cast<UINT32>(0x1),
                        true
                    },
                    {
                        3,
                        static_cast<UINT32>(0x2),
                        true
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_Storage_Streams_InputStreamOptions::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_Storage_Streams_InputStreamOptions_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl

#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IRandomAccessStreamReference::Class_Windows_Storage_Streams_IRandomAccessStreamReference(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IRandomAccessStreamReference_dispatchProperties[] =
{
    L"openReadAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IRandomAccessStreamReference::s_dispatchProperties = s_Class_Windows_Storage_Streams_IRandomAccessStreamReference_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IRandomAccessStreamReference::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamReference::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IRandomAccessStreamReference_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamReference::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamReference::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamReference::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamReference::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method OpenReadAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamReference innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>();
                            auto asyncResultAsWinRT = innerObject.OpenReadAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IInputStreamReference::Class_Windows_Storage_Streams_IInputStreamReference(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IInputStreamReference_dispatchProperties[] =
{
    L"openSequentialReadAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IInputStreamReference::s_dispatchProperties = s_Class_Windows_Storage_Streams_IInputStreamReference_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IInputStreamReference::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Storage_Streams_IInputStreamReference::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IInputStreamReference_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IInputStreamReference::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IInputStreamReference::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IInputStreamReference::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IInputStreamReference::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method OpenSequentialReadAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IInputStreamReference innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IInputStreamReference>();
                            auto asyncResultAsWinRT = innerObject.OpenSequentialReadAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IRandomAccessStream::Class_Windows_Storage_Streams_IRandomAccessStream(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IRandomAccessStream_dispatchProperties[] =
{
    L"canRead",
    L"canWrite",
    L"cloneStream",
    L"close",
    L"flushAsync",
    L"getInputStreamAt",
    L"getOutputStreamAt",
    L"position",
    L"readAsync",
    L"seek",
    L"size",
    L"writeAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IRandomAccessStream::s_dispatchProperties = s_Class_Windows_Storage_Streams_IRandomAccessStream_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IRandomAccessStream::s_dispatchIds[12] =
{
    10,
    11,
    4,
    5,
    8,
    1,
    2,
    12,
    6,
    3,
    13,
    7
};

HRESULT Class_Windows_Storage_Streams_IRandomAccessStream::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IRandomAccessStream_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStream::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStream::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 12))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStream::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStream::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetInputStreamAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.GetInputStreamAt(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetOutputStreamAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.GetOutputStreamAt(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Seek
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                    innerObject.Seek(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method CloneStream
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.CloneStream(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for async method ReadAsync
                    if (3 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto asyncResultAsWinRT = innerObject.ReadAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 0 - 1])
                                ,
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 1 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Streams::InputStreamOptions>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 2 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for async method WriteAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto asyncResultAsWinRT = innerObject.WriteAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for async method FlushAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto asyncResultAsWinRT = innerObject.FlushAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 10:
                {
                    // Invoke for CanRead
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.CanRead();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for CanWrite
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.CanWrite();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for Position
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.Position();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 13:
                {
                    // Invoke for Size
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.Size();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            innerObject.Size(
                                    Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IInputStream::Class_Windows_Storage_Streams_IInputStream(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IInputStream_dispatchProperties[] =
{
    L"close",
    L"readAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IInputStream::s_dispatchProperties = s_Class_Windows_Storage_Streams_IInputStream_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IInputStream::s_dispatchIds[2] =
{
    2,
    1
};

HRESULT Class_Windows_Storage_Streams_IInputStream::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IInputStream_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IInputStream::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IInputStream::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IInputStream::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IInputStream::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method ReadAsync
                    if (3 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IInputStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IInputStream>();
                            auto asyncResultAsWinRT = innerObject.ReadAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 0 - 1])
                                ,
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 1 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Streams::InputStreamOptions>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 2 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType_dispatchProperties[] =
{
    L"cloneStream",
    L"close",
    L"flushAsync",
    L"getInputStreamAt",
    L"getOutputStreamAt",
    L"readAsync",
    L"seek",
    L"writeAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::s_dispatchProperties = s_Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::s_dispatchIds[8] =
{
    4,
    5,
    8,
    1,
    2,
    6,
    3,
    7
};

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 8))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IRandomAccessStreamWithContentType::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetInputStreamAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.GetInputStreamAt(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method GetOutputStreamAt
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.GetOutputStreamAt(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Seek
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                    innerObject.Seek(
                                Converter<VARIANT, uint64_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for method CloneStream
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IRandomAccessStream>();
                            auto resultAsWinRT = innerObject.CloneStream(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for async method ReadAsync
                    if (3 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.ReadAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 0 - 1])
                                ,
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 1 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Streams::InputStreamOptions>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 2 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for async method ReadAsync
                    if (3 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.ReadAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 0 - 1])
                                ,
                                Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 1 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::Storage::Streams::InputStreamOptions>(m_dispatchAdapter).Convert(dispParams->rgvarg[3 - 2 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for async method WriteAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.WriteAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for async method WriteAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.WriteAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for async method FlushAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.FlushAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for async method FlushAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>();
                            auto asyncResultAsWinRT = innerObject.FlushAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IOutputStream::Class_Windows_Storage_Streams_IOutputStream(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IOutputStream_dispatchProperties[] =
{
    L"close",
    L"flushAsync",
    L"writeAsync"
};
DispatchProperties Class_Windows_Storage_Streams_IOutputStream::s_dispatchProperties = s_Class_Windows_Storage_Streams_IOutputStream_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IOutputStream::s_dispatchIds[3] =
{
    3,
    2,
    1
};

HRESULT Class_Windows_Storage_Streams_IOutputStream::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IOutputStream_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IOutputStream::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IOutputStream::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IOutputStream::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IOutputStream::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method WriteAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IOutputStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IOutputStream>();
                            auto asyncResultAsWinRT = innerObject.WriteAsync(
                                Converter<VARIANT, winrt::Windows::Storage::Streams::IBuffer>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for async method FlushAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Storage::Streams::IOutputStream innerObject = m_innerObject
                                    .as<winrt::Windows::Storage::Streams::IOutputStream>();
                            auto asyncResultAsWinRT = innerObject.FlushAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method Close
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Foundation::IClosable>();
                    innerObject.Close(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IBuffer::Class_Windows_Storage_Streams_IBuffer(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IBuffer_dispatchProperties[] =
{
    L"capacity",
    L"length"
};
DispatchProperties Class_Windows_Storage_Streams_IBuffer::s_dispatchProperties = s_Class_Windows_Storage_Streams_IBuffer_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IBuffer::s_dispatchIds[2] =
{
    2,
    3
};

HRESULT Class_Windows_Storage_Streams_IBuffer::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IBuffer_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IBuffer::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IBuffer::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IBuffer::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IBuffer::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for Capacity
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IBuffer>();
                            auto resultAsWinRT = innerObject.Capacity();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for Length
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IBuffer>();
                            auto resultAsWinRT = innerObject.Length();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    if (flags == DISPATCH_PROPERTYPUT)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IBuffer>();
                            innerObject.Length(
                                    Converter<VARIANT, uint32_t>(m_dispatchAdapter).Convert(*(dispParams->rgvarg)));
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Storage_Streams_IContentTypeProvider::Class_Windows_Storage_Streams_IContentTypeProvider(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Storage_Streams_IContentTypeProvider_dispatchProperties[] =
{
    L"contentType"
};
DispatchProperties Class_Windows_Storage_Streams_IContentTypeProvider::s_dispatchProperties = s_Class_Windows_Storage_Streams_IContentTypeProvider_dispatchProperties;
const DISPID Class_Windows_Storage_Streams_IContentTypeProvider::s_dispatchIds[1] =
{
    2
};

HRESULT Class_Windows_Storage_Streams_IContentTypeProvider::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Storage_Streams_IContentTypeProvider_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Storage_Streams_IContentTypeProvider::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Storage_Streams_IContentTypeProvider::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Storage_Streams_IContentTypeProvider::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Storage_Streams_IContentTypeProvider::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for ContentType
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Storage::Streams::IContentTypeProvider>();
                            auto resultAsWinRT = innerObject.ContentType();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}


