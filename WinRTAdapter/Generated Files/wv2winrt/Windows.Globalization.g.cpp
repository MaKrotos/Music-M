// WARNING: Please don't edit this file. It was generated by wv2winrt v1.0.0.0
#include "pch.h"

#include "wv2winrt/asyncdispatch.h"
#include "wv2winrt/converter.h"
#include "wv2winrt/eventargsdispatch.h"
#include "wv2winrt/implicitstructs.g.h"
#include "wv2winrt/main.h"
#include "wv2winrt/returnaggregator.h"
#include "wv2winrt/uniquevariant.h"
#include "wv2winrt/Windows.Globalization.g.h"
#include "wv2winrt/Windows.Globalization.g.h"
#include "wv2winrt/Windows.Globalization.g.h"
#include "wv2winrt/Windows.Globalization.g.h"
#include "winrt/Windows.Globalization.h"
#include "winrt/Windows.Foundation.Collections.h"


namespace wv2winrt_impl
{
Namespace_Windows_Globalization::Namespace_Windows_Globalization(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Namespace_Windows_Globalization_dispatchProperties[] =
{
    L"DayOfWeek",
    L"Language",
    L"LanguageLayoutDirection"
};
DispatchProperties Namespace_Windows_Globalization::s_dispatchProperties = s_Namespace_Windows_Globalization_dispatchProperties;

const DISPID Namespace_Windows_Globalization::s_dispatchIds[3] =
{
    50,
    10,
    9
};

HRESULT Namespace_Windows_Globalization::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Namespace_Windows_Globalization_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Namespace_Windows_Globalization::GetIDsOfNames(REFIID riid,
                                                  LPOLESTR* names,
                                                  unsigned int namesCount,
                                                  LCID localeId,
                                                  DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Namespace_Windows_Globalization::Invoke(DISPID dispId,
                                           REFIID riid,
                                           LCID localeId,
                                           WORD flags,
                                           DISPPARAMS* dispParams,
                                           VARIANT* result,
                                           EXCEPINFO* excepInfo,
                                           UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                winrt::com_ptr<IDispatch> dispatch;
#pragma warning( push )
#pragma warning( disable: 4065 )
                switch (dispId)
                {
                    case 9:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Globalization.LanguageLayoutDirection", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 50:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Globalization.DayOfWeek", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 10:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.Globalization.Language", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }

                    default:
                        hr = DISP_E_MEMBERNOTFOUND;
                        break;
                }
#pragma warning( pop )

                if (SUCCEEDED(hr))
                {
                    // Copy dispatch into output result
                    VARIANT dispatchAsVariant;
                    dispatchAsVariant.vt = VT_DISPATCH;
                    dispatchAsVariant.pdispVal = dispatch.detach();
                    *result = dispatchAsVariant;
                }
            }
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_Globalization_LanguageLayoutDirection::Enum_Windows_Globalization_LanguageLayoutDirection(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_Globalization_LanguageLayoutDirection_dispatchProperties[] =
{
    L"ltr",
    L"rtl",
    L"ttbLtr",
    L"ttbRtl"
};
DispatchProperties Enum_Windows_Globalization_LanguageLayoutDirection::s_dispatchProperties = s_Enum_Windows_Globalization_LanguageLayoutDirection_dispatchProperties;

const DISPID Enum_Windows_Globalization_LanguageLayoutDirection::s_dispatchIds[4] =
{
    1,
    2,
    3,
    4
};

HRESULT Enum_Windows_Globalization_LanguageLayoutDirection::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_Globalization_LanguageLayoutDirection::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_Globalization_LanguageLayoutDirection::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_Globalization_LanguageLayoutDirection_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_Globalization_DayOfWeek::Enum_Windows_Globalization_DayOfWeek(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_Globalization_DayOfWeek_dispatchProperties[] =
{
    L"friday",
    L"monday",
    L"saturday",
    L"sunday",
    L"thursday",
    L"tuesday",
    L"wednesday"
};
DispatchProperties Enum_Windows_Globalization_DayOfWeek::s_dispatchProperties = s_Enum_Windows_Globalization_DayOfWeek_dispatchProperties;

const DISPID Enum_Windows_Globalization_DayOfWeek::s_dispatchIds[7] =
{
    6,
    2,
    7,
    1,
    5,
    3,
    4
};

HRESULT Enum_Windows_Globalization_DayOfWeek::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 7))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_Globalization_DayOfWeek::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        5,
                        static_cast<UINT32>(4),
                        false
                    },
                    {
                        6,
                        static_cast<UINT32>(5),
                        false
                    },
                    {
                        7,
                        static_cast<UINT32>(6),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_Globalization_DayOfWeek::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_Globalization_DayOfWeek_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl

#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguageFactory::Class_Windows_Globalization_ILanguageFactory(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguageFactory_dispatchProperties[] =
{
    L"createLanguage"
};
DispatchProperties Class_Windows_Globalization_ILanguageFactory::s_dispatchProperties = s_Class_Windows_Globalization_ILanguageFactory_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguageFactory::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Globalization_ILanguageFactory::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguageFactory_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguageFactory::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguageFactory::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageFactory::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageFactory::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method CreateLanguage
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguageFactory>();
                            auto resultAsWinRT = innerObject.CreateLanguage(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_Language::Class_Windows_Globalization_Language(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_Language_dispatchProperties[] =
{
    L"abbreviatedName",
    L"displayName",
    L"getExtensionSubtags",
    L"languageTag",
    L"layoutDirection",
    L"nativeName",
    L"script"
};
DispatchProperties Class_Windows_Globalization_Language::s_dispatchProperties = s_Class_Windows_Globalization_Language_dispatchProperties;
const DISPID Class_Windows_Globalization_Language::s_dispatchIds[7] =
{
    11,
    6,
    1,
    7,
    10,
    8,
    9
};

HRESULT Class_Windows_Globalization_Language::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_Language_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_Language::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_Language::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 7))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_Language::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_Language::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetExtensionSubtags
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguageExtensionSubtags>();
                            auto resultAsWinRT = innerObject.GetExtensionSubtags(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 6:
                {
                    // Invoke for DisplayName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.DisplayName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for LanguageTag
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.LanguageTag();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 8:
                {
                    // Invoke for NativeName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.NativeName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 9:
                {
                    // Invoke for Script
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.Script();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 10:
                {
                    // Invoke for LayoutDirection
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.LayoutDirection();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for AbbreviatedName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::Language>();
                            auto resultAsWinRT = innerObject.AbbreviatedName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguageExtensionSubtags::Class_Windows_Globalization_ILanguageExtensionSubtags(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguageExtensionSubtags_dispatchProperties[] =
{
    L"getExtensionSubtags"
};
DispatchProperties Class_Windows_Globalization_ILanguageExtensionSubtags::s_dispatchProperties = s_Class_Windows_Globalization_ILanguageExtensionSubtags_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguageExtensionSubtags::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Globalization_ILanguageExtensionSubtags::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguageExtensionSubtags_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguageExtensionSubtags::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguageExtensionSubtags::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageExtensionSubtags::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageExtensionSubtags::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetExtensionSubtags
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguageExtensionSubtags>();
                            auto resultAsWinRT = innerObject.GetExtensionSubtags(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguageStatics3::Class_Windows_Globalization_ILanguageStatics3(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguageStatics3_dispatchProperties[] =
{
    L"getMuiCompatibleLanguageListFromLanguageTags"
};
DispatchProperties Class_Windows_Globalization_ILanguageStatics3::s_dispatchProperties = s_Class_Windows_Globalization_ILanguageStatics3_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguageStatics3::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_Globalization_ILanguageStatics3::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguageStatics3_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguageStatics3::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguageStatics3::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageStatics3::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguageStatics3::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetMuiCompatibleLanguageListFromLanguageTags
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguageStatics3>();
                            auto resultAsWinRT = innerObject.GetMuiCompatibleLanguageListFromLanguageTags(
                                Converter<VARIANT, winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguage::Class_Windows_Globalization_ILanguage(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguage_dispatchProperties[] =
{
    L"displayName",
    L"languageTag",
    L"nativeName",
    L"script"
};
DispatchProperties Class_Windows_Globalization_ILanguage::s_dispatchProperties = s_Class_Windows_Globalization_ILanguage_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguage::s_dispatchIds[4] =
{
    2,
    3,
    4,
    5
};

HRESULT Class_Windows_Globalization_ILanguage::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguage_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguage::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguage::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for DisplayName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage>();
                            auto resultAsWinRT = innerObject.DisplayName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for LanguageTag
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage>();
                            auto resultAsWinRT = innerObject.LanguageTag();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for NativeName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage>();
                            auto resultAsWinRT = innerObject.NativeName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for Script
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage>();
                            auto resultAsWinRT = innerObject.Script();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguage2::Class_Windows_Globalization_ILanguage2(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguage2_dispatchProperties[] =
{
    L"layoutDirection"
};
DispatchProperties Class_Windows_Globalization_ILanguage2::s_dispatchProperties = s_Class_Windows_Globalization_ILanguage2_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguage2::s_dispatchIds[1] =
{
    2
};

HRESULT Class_Windows_Globalization_ILanguage2::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguage2_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguage2::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguage2::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage2::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage2::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for LayoutDirection
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage2>();
                            auto resultAsWinRT = innerObject.LayoutDirection();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_Globalization_ILanguage3::Class_Windows_Globalization_ILanguage3(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_Globalization_ILanguage3_dispatchProperties[] =
{
    L"abbreviatedName"
};
DispatchProperties Class_Windows_Globalization_ILanguage3::s_dispatchProperties = s_Class_Windows_Globalization_ILanguage3_dispatchProperties;
const DISPID Class_Windows_Globalization_ILanguage3::s_dispatchIds[1] =
{
    2
};

HRESULT Class_Windows_Globalization_ILanguage3::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_Globalization_ILanguage3_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_Globalization_ILanguage3::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_Globalization_ILanguage3::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage3::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_Globalization_ILanguage3::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for AbbreviatedName
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::Globalization::ILanguage3>();
                            auto resultAsWinRT = innerObject.AbbreviatedName();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
Static_Class_Windows_Globalization_Language::Static_Class_Windows_Globalization_Language(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Static_Class_Windows_Globalization_Language_dispatchProperties[] =
{
    L"currentInputMethodLanguageTag",
    L"getMuiCompatibleLanguageListFromLanguageTags",
    L"isWellFormed",
    L"trySetInputMethodLanguageTag"
};
DispatchProperties Static_Class_Windows_Globalization_Language::s_dispatchProperties = s_Static_Class_Windows_Globalization_Language_dispatchProperties;

const DISPID Static_Class_Windows_Globalization_Language::s_dispatchIds[4] =
{
    12,
    1,
    3,
    2
};

HRESULT Static_Class_Windows_Globalization_Language::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Static_Class_Windows_Globalization_Language_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Static_Class_Windows_Globalization_Language::GetIDsOfNames(
    REFIID riid,
    LPOLESTR* names,
    unsigned int namesCount,
    LCID localeId,
    DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Static_Class_Windows_Globalization_Language::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                // 0 is the special dispId refering to the current object.
                // We use it here to mean you are invoking a constructor.
                case 0:
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::Globalization::Language resultAsWinRT {
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])

                                };

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                case 1:
                {
                    // Invoke for GetMuiCompatibleLanguageListFromLanguageTags
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Globalization::Language::GetMuiCompatibleLanguageListFromLanguageTags(
                                Converter<VARIANT, winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for TrySetInputMethodLanguageTag
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Globalization::Language::TrySetInputMethodLanguageTag(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for IsWellFormed
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Globalization::Language::IsWellFormed(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 12:
                {
                    // Invoke for CurrentInputMethodLanguageTag
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::Globalization::Language::CurrentInputMethodLanguageTag();
                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}


