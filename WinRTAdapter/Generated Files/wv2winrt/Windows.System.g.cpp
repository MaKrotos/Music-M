// WARNING: Please don't edit this file. It was generated by wv2winrt v1.0.0.0
#include "pch.h"

#include "wv2winrt/asyncdispatch.h"
#include "wv2winrt/converter.h"
#include "wv2winrt/eventargsdispatch.h"
#include "wv2winrt/implicitstructs.g.h"
#include "wv2winrt/main.h"
#include "wv2winrt/returnaggregator.h"
#include "wv2winrt/uniquevariant.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.UserProfile.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "wv2winrt/Windows.System.g.h"
#include "winrt/Windows.System.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"


namespace wv2winrt_impl
{
Namespace_Windows_System::Namespace_Windows_System(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Namespace_Windows_System_dispatchProperties[] =
{
    L"User",
    L"UserAgeConsentGroup",
    L"UserAgeConsentResult",
    L"UserAuthenticationStatus",
    L"UserPictureSize",
    L"UserProfile",
    L"UserType",
    L"UserWatcherStatus",
    L"UserWatcherUpdateKind"
};
DispatchProperties Namespace_Windows_System::s_dispatchProperties = s_Namespace_Windows_System_dispatchProperties;

const DISPID Namespace_Windows_System::s_dispatchIds[9] =
{
    45,
    64,
    121,
    69,
    61,
    3,
    68,
    124,
    295
};

HRESULT Namespace_Windows_System::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Namespace_Windows_System_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Namespace_Windows_System::GetIDsOfNames(REFIID riid,
                                                  LPOLESTR* names,
                                                  unsigned int namesCount,
                                                  LCID localeId,
                                                  DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 9))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Namespace_Windows_System::Invoke(DISPID dispId,
                                           REFIID riid,
                                           LCID localeId,
                                           WORD flags,
                                           DISPPARAMS* dispParams,
                                           VARIANT* result,
                                           EXCEPINFO* excepInfo,
                                           UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                winrt::com_ptr<IDispatch> dispatch;
#pragma warning( push )
#pragma warning( disable: 4065 )
                switch (dispId)
                {
                    case 3:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserProfile", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 61:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserPictureSize", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 64:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserAgeConsentGroup", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 68:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserType", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 69:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserAuthenticationStatus", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 121:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserAgeConsentResult", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 124:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserWatcherStatus", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 295:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.UserWatcherUpdateKind", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }
                    case 45:
                    {
                        dispatch = m_dispatchAdapter.WrapNamedObject(L"Windows.System.User", m_dispatchAdapter).as<IDispatch>();
                        hr = S_OK;
                        break;
                    }

                    default:
                        hr = DISP_E_MEMBERNOTFOUND;
                        break;
                }
#pragma warning( pop )

                if (SUCCEEDED(hr))
                {
                    // Copy dispatch into output result
                    VARIANT dispatchAsVariant;
                    dispatchAsVariant.vt = VT_DISPATCH;
                    dispatchAsVariant.pdispVal = dispatch.detach();
                    *result = dispatchAsVariant;
                }
            }
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserPictureSize::Enum_Windows_System_UserPictureSize(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserPictureSize_dispatchProperties[] =
{
    L"size1080x1080",
    L"size208x208",
    L"size424x424",
    L"size64x64"
};
DispatchProperties Enum_Windows_System_UserPictureSize::s_dispatchProperties = s_Enum_Windows_System_UserPictureSize_dispatchProperties;

const DISPID Enum_Windows_System_UserPictureSize::s_dispatchIds[4] =
{
    4,
    2,
    3,
    1
};

HRESULT Enum_Windows_System_UserPictureSize::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserPictureSize::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserPictureSize::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserPictureSize_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserAgeConsentGroup::Enum_Windows_System_UserAgeConsentGroup(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserAgeConsentGroup_dispatchProperties[] =
{
    L"adult",
    L"child",
    L"minor"
};
DispatchProperties Enum_Windows_System_UserAgeConsentGroup::s_dispatchProperties = s_Enum_Windows_System_UserAgeConsentGroup_dispatchProperties;

const DISPID Enum_Windows_System_UserAgeConsentGroup::s_dispatchIds[3] =
{
    3,
    1,
    2
};

HRESULT Enum_Windows_System_UserAgeConsentGroup::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAgeConsentGroup::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAgeConsentGroup::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserAgeConsentGroup_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserType::Enum_Windows_System_UserType(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserType_dispatchProperties[] =
{
    L"localGuest",
    L"localUser",
    L"remoteGuest",
    L"remoteUser",
    L"systemManaged"
};
DispatchProperties Enum_Windows_System_UserType::s_dispatchProperties = s_Enum_Windows_System_UserType_dispatchProperties;

const DISPID Enum_Windows_System_UserType::s_dispatchIds[5] =
{
    3,
    1,
    4,
    2,
    5
};

HRESULT Enum_Windows_System_UserType::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserType::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        5,
                        static_cast<UINT32>(4),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserType::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserType_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserAuthenticationStatus::Enum_Windows_System_UserAuthenticationStatus(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserAuthenticationStatus_dispatchProperties[] =
{
    L"locallyAuthenticated",
    L"remotelyAuthenticated",
    L"unauthenticated"
};
DispatchProperties Enum_Windows_System_UserAuthenticationStatus::s_dispatchProperties = s_Enum_Windows_System_UserAuthenticationStatus_dispatchProperties;

const DISPID Enum_Windows_System_UserAuthenticationStatus::s_dispatchIds[3] =
{
    2,
    3,
    1
};

HRESULT Enum_Windows_System_UserAuthenticationStatus::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAuthenticationStatus::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAuthenticationStatus::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserAuthenticationStatus_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserAgeConsentResult::Enum_Windows_System_UserAgeConsentResult(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserAgeConsentResult_dispatchProperties[] =
{
    L"ambiguous",
    L"included",
    L"notEnforced",
    L"notIncluded",
    L"unknown"
};
DispatchProperties Enum_Windows_System_UserAgeConsentResult::s_dispatchProperties = s_Enum_Windows_System_UserAgeConsentResult_dispatchProperties;

const DISPID Enum_Windows_System_UserAgeConsentResult::s_dispatchIds[5] =
{
    5,
    2,
    1,
    3,
    4
};

HRESULT Enum_Windows_System_UserAgeConsentResult::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 5))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAgeConsentResult::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        5,
                        static_cast<UINT32>(4),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserAgeConsentResult::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserAgeConsentResult_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserWatcherStatus::Enum_Windows_System_UserWatcherStatus(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserWatcherStatus_dispatchProperties[] =
{
    L"aborted",
    L"created",
    L"enumerationCompleted",
    L"started",
    L"stopped",
    L"stopping"
};
DispatchProperties Enum_Windows_System_UserWatcherStatus::s_dispatchProperties = s_Enum_Windows_System_UserWatcherStatus_dispatchProperties;

const DISPID Enum_Windows_System_UserWatcherStatus::s_dispatchIds[6] =
{
    6,
    1,
    3,
    2,
    5,
    4
};

HRESULT Enum_Windows_System_UserWatcherStatus::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 6))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserWatcherStatus::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    },
                    {
                        3,
                        static_cast<UINT32>(2),
                        false
                    },
                    {
                        4,
                        static_cast<UINT32>(3),
                        false
                    },
                    {
                        5,
                        static_cast<UINT32>(4),
                        false
                    },
                    {
                        6,
                        static_cast<UINT32>(5),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserWatcherStatus::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserWatcherStatus_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl
namespace wv2winrt_impl
{
// We match the namespace types which do need the DispatchAdapter in the
// constructor even though the enum types do not require the DispatchAdapter.
Enum_Windows_System_UserWatcherUpdateKind::Enum_Windows_System_UserWatcherUpdateKind(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter&)
{
}

const static wchar_t* const s_Enum_Windows_System_UserWatcherUpdateKind_dispatchProperties[] =
{
    L"picture",
    L"properties"
};
DispatchProperties Enum_Windows_System_UserWatcherUpdateKind::s_dispatchProperties = s_Enum_Windows_System_UserWatcherUpdateKind_dispatchProperties;

const DISPID Enum_Windows_System_UserWatcherUpdateKind::s_dispatchIds[2] =
{
    2,
    1
};

HRESULT Enum_Windows_System_UserWatcherUpdateKind::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserWatcherUpdateKind::Invoke(DISPID dispId,
                                      REFIID riid,
                                      LCID localeId,
                                      WORD flags,
                                      DISPPARAMS* dispParams,
                                      VARIANT* result,
                                      EXCEPINFO* excepInfo,
                                      UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_PROPERTYGET)
        {
            if (dispParams->cArgs != 0 ||
                dispParams->rgvarg != nullptr)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                struct EnumEntry
                {
                    DISPID id;
                    UINT32 value;
                    bool isValueUnsigned;
                };
                static const EnumEntry enumEntries[] =
                {
                    {
                        1,
                        static_cast<UINT32>(0),
                        false
                    },
                    {
                        2,
                        static_cast<UINT32>(1),
                        false
                    }
                };
                static const size_t enumEntriesCount = ARRAYSIZE(enumEntries);
                const size_t requestIdx = dispId - 1;

                if (requestIdx < enumEntriesCount)
                {
                    if (enumEntries[requestIdx].isValueUnsigned)
                    {
                        result->vt = VT_UI4;
                        result->uintVal = enumEntries[requestIdx].value;
                        hr = S_OK;
                    }
                    else
                    {
                        result->vt = VT_I4;
                        result->intVal = static_cast<INT32>(enumEntries[requestIdx].value);
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT Enum_Windows_System_UserWatcherUpdateKind::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Enum_Windows_System_UserWatcherUpdateKind_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

}  // namespace wv2winrt_impl

#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_User::Class_Windows_System_User(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_User_dispatchProperties[] =
{
    L"authenticationStatus",
    L"checkUserAgeConsentGroupAsync",
    L"getPictureAsync",
    L"getPropertiesAsync",
    L"getPropertyAsync",
    L"nonRoamableId",
    L"type"
};
DispatchProperties Class_Windows_System_User::s_dispatchProperties = s_Class_Windows_System_User_dispatchProperties;
const DISPID Class_Windows_System_User::s_dispatchIds[7] =
{
    10,
    4,
    3,
    2,
    1,
    11,
    12
};

HRESULT Class_Windows_System_User::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_User_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_User::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_User::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 7))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_User::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_User::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method GetPropertyAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::User innerObject = m_innerObject
                                    .as<winrt::Windows::System::User>();
                            auto asyncResultAsWinRT = innerObject.GetPropertyAsync(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for async method GetPropertiesAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::User innerObject = m_innerObject
                                    .as<winrt::Windows::System::User>();
                            auto asyncResultAsWinRT = innerObject.GetPropertiesAsync(
                                Converter<VARIANT, winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for async method GetPictureAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::User innerObject = m_innerObject
                                    .as<winrt::Windows::System::User>();
                            auto asyncResultAsWinRT = innerObject.GetPictureAsync(
                                Converter<VARIANT, winrt::Windows::System::UserPictureSize>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for async method CheckUserAgeConsentGroupAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::User innerObject = m_innerObject
                                    .as<winrt::Windows::System::User>();
                            auto asyncResultAsWinRT = innerObject.CheckUserAgeConsentGroupAsync(
                                Converter<VARIANT, winrt::Windows::System::UserAgeConsentGroup>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 10:
                {
                    // Invoke for AuthenticationStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::User>();
                            auto resultAsWinRT = innerObject.AuthenticationStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 11:
                {
                    // Invoke for NonRoamableId
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::User>();
                            auto resultAsWinRT = innerObject.NonRoamableId();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 12:
                {
                    // Invoke for Type
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::User>();
                            auto resultAsWinRT = innerObject.Type();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUser::Class_Windows_System_IUser(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUser_dispatchProperties[] =
{
    L"authenticationStatus",
    L"getPictureAsync",
    L"getPropertiesAsync",
    L"getPropertyAsync",
    L"nonRoamableId",
    L"type"
};
DispatchProperties Class_Windows_System_IUser::s_dispatchProperties = s_Class_Windows_System_IUser_dispatchProperties;
const DISPID Class_Windows_System_IUser::s_dispatchIds[6] =
{
    5,
    3,
    2,
    1,
    6,
    7
};

HRESULT Class_Windows_System_IUser::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUser_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUser::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUser::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 6))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUser::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUser::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method GetPropertyAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUser innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUser>();
                            auto asyncResultAsWinRT = innerObject.GetPropertyAsync(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for async method GetPropertiesAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUser innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUser>();
                            auto asyncResultAsWinRT = innerObject.GetPropertiesAsync(
                                Converter<VARIANT, winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for async method GetPictureAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUser innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUser>();
                            auto asyncResultAsWinRT = innerObject.GetPictureAsync(
                                Converter<VARIANT, winrt::Windows::System::UserPictureSize>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 5:
                {
                    // Invoke for AuthenticationStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUser>();
                            auto resultAsWinRT = innerObject.AuthenticationStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 6:
                {
                    // Invoke for NonRoamableId
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUser>();
                            auto resultAsWinRT = innerObject.NonRoamableId();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 7:
                {
                    // Invoke for Type
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUser>();
                            auto resultAsWinRT = innerObject.Type();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUser2::Class_Windows_System_IUser2(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUser2_dispatchProperties[] =
{
    L"checkUserAgeConsentGroupAsync"
};
DispatchProperties Class_Windows_System_IUser2::s_dispatchProperties = s_Class_Windows_System_IUser2_dispatchProperties;
const DISPID Class_Windows_System_IUser2::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_System_IUser2::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUser2_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUser2::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUser2::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUser2::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUser2::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for async method CheckUserAgeConsentGroupAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUser2 innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUser2>();
                            auto asyncResultAsWinRT = innerObject.CheckUserAgeConsentGroupAsync(
                                Converter<VARIANT, winrt::Windows::System::UserAgeConsentGroup>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserStatics::Class_Windows_System_IUserStatics(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserStatics_dispatchProperties[] =
{
    L"createWatcher",
    L"findAllAsync",
    L"getFromId"
};
DispatchProperties Class_Windows_System_IUserStatics::s_dispatchProperties = s_Class_Windows_System_IUserStatics_dispatchProperties;
const DISPID Class_Windows_System_IUserStatics::s_dispatchIds[3] =
{
    1,
    2,
    3
};

HRESULT Class_Windows_System_IUserStatics::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserStatics_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserStatics::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserStatics::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserStatics::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserStatics::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method CreateWatcher
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserStatics>();
                            auto resultAsWinRT = innerObject.CreateWatcher(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for async method FindAllAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUserStatics innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserStatics>();
                            auto asyncResultAsWinRT = innerObject.FindAllAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for async method FindAllAsync
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUserStatics innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserStatics>();
                            auto asyncResultAsWinRT = innerObject.FindAllAsync(
                                Converter<VARIANT, winrt::Windows::System::UserType>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else // Invoke for async method FindAllAsync
                    if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            winrt::Windows::System::IUserStatics innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserStatics>();
                            auto asyncResultAsWinRT = innerObject.FindAllAsync(
                                Converter<VARIANT, winrt::Windows::System::UserType>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::System::UserAuthenticationStatus>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for method GetFromId
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserStatics>();
                            auto resultAsWinRT = innerObject.GetFromId(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_UserWatcher::Class_Windows_System_UserWatcher(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_UserWatcher_dispatchProperties[] =
{
    L"start",
    L"status",
    L"stop"
};
DispatchProperties Class_Windows_System_UserWatcher::s_dispatchProperties = s_Class_Windows_System_UserWatcher_dispatchProperties;
const DISPID Class_Windows_System_UserWatcher::s_dispatchIds[3] =
{
    1,
    4,
    2
};

HRESULT Class_Windows_System_UserWatcher::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_UserWatcher_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_UserWatcher::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_UserWatcher::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (FAILED(hr) && wcscmp(names[0], L"addEventListener") == 0)
        {
            *dispId = 7;
            hr = S_OK;
        }
        else if (FAILED(hr) && wcscmp(names[0], L"removeEventListener") == 0)
        {
            *dispId = 7 + 1;
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_UserWatcher::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_UserWatcher::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Start
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserWatcher>();
                    innerObject.Start(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Stop
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserWatcher>();
                    innerObject.Stop(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                case 7:
                    // addEventListener(name, callback) Invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"added") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAdded.find(callback.get()) ==
                                        m_eventRegistrationAdded.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Added(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"added", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAdded[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanged") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAuthenticationStatusChanged.find(callback.get()) ==
                                        m_eventRegistrationAuthenticationStatusChanged.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.AuthenticationStatusChanged(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"authenticationStatusChanged", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAuthenticationStatusChanged[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanging") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAuthenticationStatusChanging.find(callback.get()) ==
                                        m_eventRegistrationAuthenticationStatusChanging.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.AuthenticationStatusChanging(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"authenticationStatusChanging", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAuthenticationStatusChanging[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"enumerationCompleted") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationEnumerationCompleted.find(callback.get()) ==
                                        m_eventRegistrationEnumerationCompleted.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.EnumerationCompleted(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"enumerationCompleted", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationEnumerationCompleted[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"removed") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationRemoved.find(callback.get()) ==
                                        m_eventRegistrationRemoved.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Removed(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"removed", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationRemoved[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"stopped") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationStopped.find(callback.get()) ==
                                        m_eventRegistrationStopped.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Stopped(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"stopped", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationStopped[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"updated") == 0)
                            {
                                winrt::Windows::System::UserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::UserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationUpdated.find(callback.get()) ==
                                        m_eventRegistrationUpdated.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Updated(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"updated", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationUpdated[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else
                            {
                                // AddEventListener silently ignores subscriptions to events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                case 7 + 1:
                    // removeEventListener(name, callback) invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"added") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAdded.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanged") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAuthenticationStatusChanged.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanging") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAuthenticationStatusChanging.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"enumerationCompleted") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationEnumerationCompleted.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"removed") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationRemoved.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"stopped") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationStopped.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"updated") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationUpdated.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else
                            {
                                // RemoveEventListener silently ignores unregistering events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Status
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserWatcher>();
                            auto resultAsWinRT = innerObject.Status();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserWatcher::Class_Windows_System_IUserWatcher(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserWatcher_dispatchProperties[] =
{
    L"start",
    L"status",
    L"stop"
};
DispatchProperties Class_Windows_System_IUserWatcher::s_dispatchProperties = s_Class_Windows_System_IUserWatcher_dispatchProperties;
const DISPID Class_Windows_System_IUserWatcher::s_dispatchIds[3] =
{
    1,
    4,
    2
};

HRESULT Class_Windows_System_IUserWatcher::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserWatcher_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserWatcher::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserWatcher::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 3))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
        if (FAILED(hr) && wcscmp(names[0], L"addEventListener") == 0)
        {
            *dispId = 7;
            hr = S_OK;
        }
        else if (FAILED(hr) && wcscmp(names[0], L"removeEventListener") == 0)
        {
            *dispId = 7 + 1;
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserWatcher::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserWatcher::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Start
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserWatcher>();
                    innerObject.Start(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for method Stop
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserWatcher>();
                    innerObject.Stop(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                case 7:
                    // addEventListener(name, callback) Invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"added") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAdded.find(callback.get()) ==
                                        m_eventRegistrationAdded.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Added(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"added", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAdded[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanged") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAuthenticationStatusChanged.find(callback.get()) ==
                                        m_eventRegistrationAuthenticationStatusChanged.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.AuthenticationStatusChanged(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"authenticationStatusChanged", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAuthenticationStatusChanged[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanging") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationAuthenticationStatusChanging.find(callback.get()) ==
                                        m_eventRegistrationAuthenticationStatusChanging.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.AuthenticationStatusChanging(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"authenticationStatusChanging", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationAuthenticationStatusChanging[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"enumerationCompleted") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationEnumerationCompleted.find(callback.get()) ==
                                        m_eventRegistrationEnumerationCompleted.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.EnumerationCompleted(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"enumerationCompleted", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationEnumerationCompleted[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"removed") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationRemoved.find(callback.get()) ==
                                        m_eventRegistrationRemoved.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Removed(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"removed", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationRemoved[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"stopped") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationStopped.find(callback.get()) ==
                                        m_eventRegistrationStopped.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Stopped(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"stopped", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationStopped[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else if (_wcsicmp(eventName.c_str(), L"updated") == 0)
                            {
                                winrt::Windows::System::IUserWatcher innerObject = m_innerObject
                                    .as<winrt::Windows::System::IUserWatcher>();

                                winrt::com_ptr<::IDispatch> callback;
                                hr = dispParams->rgvarg[0].pdispVal->QueryInterface(callback.put());
                                if (SUCCEEDED(hr))
                                {
                                    // Subsequent identical registrations are discarded.
                                    if (m_eventRegistrationUpdated.find(callback.get()) ==
                                        m_eventRegistrationUpdated.end())
                                    {
                                        auto dispatchAdapter = m_dispatchAdapter; // Copy for the lambda capture
                                        // subscribe to event
                                        auto revoker = innerObject.Updated(
                                            winrt::auto_revoke,
                                            [callback, dispatchAdapter](const auto& sender, const auto& args) {
                                                UniqueVariant senderAsVARIANT(
                                                    Converter<decltype(sender), VARIANT>(dispatchAdapter).
                                                        Convert(sender));
                                                UniqueVariant argsAsVARIANT(
                                                    Converter<decltype(args), VARIANT>(dispatchAdapter).
                                                        Convert(args));
                                                IDispatch* senderAsIDispatch = nullptr; // Weak ref. Do not release.
                                                if (senderAsVARIANT.vt == VT_DISPATCH)
                                                {
                                                    senderAsIDispatch = senderAsVARIANT.pdispVal;
                                                }
                                                VARIANT paramsAsVARIANTs[1] = { argsAsVARIANT };
                                                winrt::com_ptr<IDispatch> aggregateEventArgs;
                                                if (SUCCEEDED(CreateAggregateEventArgs(L"updated", senderAsIDispatch, paramsAsVARIANTs, 1, aggregateEventArgs.put())))
                                                {
                                                    // Ownership is passed to the callback below
                                                    VARIANT aggregateEventArgsAsVARIANT{VT_DISPATCH};
                                                    aggregateEventArgsAsVARIANT.pdispVal = aggregateEventArgs.get();
                                                    DISPPARAMS callbackDispParams = {};
                                                    VARIANT callbackDispParamsVarg[1] = {};
                                                    callbackDispParams.cArgs = ARRAYSIZE(callbackDispParamsVarg);
                                                    callbackDispParams.rgvarg = &callbackDispParamsVarg[0];
                                                    callbackDispParams.rgvarg[0] = aggregateEventArgsAsVARIANT;

                                                    // We don't actually do anything with the result, but we collect it in case
                                                    // the callback doesn't check for nullptr out parameters.
                                                    UniqueVariant callbackResult;
                                                    EXCEPINFO excepInfo;
                                                    UINT argErr;
                                                    callback->Invoke(
                                                        DISPID_VALUE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                                        &callbackDispParams, &callbackResult,
                                                        &excepInfo, &argErr);
                                                }
                                        });
                                        m_eventRegistrationUpdated[callback.get()] =
                                            std::move(revoker);
                                    }
                                }
                            }
                            else
                            {
                                // AddEventListener silently ignores subscriptions to events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                case 7 + 1:
                    // removeEventListener(name, callback) invoke method
                    if (2 == dispParams->cArgs)
                    {
                        // Remember that rgvarg stores parameters in reverse order.
                        std::wstring eventName =
                            Converter<VARIANT, std::wstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1]);
                        if (dispParams->rgvarg[0].vt == VT_DISPATCH &&
                            dispParams->rgvarg[0].pdispVal != nullptr)
                        {
                            if (_wcsicmp(eventName.c_str(), L"added") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAdded.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanged") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAuthenticationStatusChanged.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"authenticationStatusChanging") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationAuthenticationStatusChanging.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"enumerationCompleted") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationEnumerationCompleted.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"removed") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationRemoved.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"stopped") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationStopped.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else if (_wcsicmp(eventName.c_str(), L"updated") == 0)
                            {
                                // We use the callback IDispatch* as the key. Its stored only
                                // as a value, weakly.
                                // Because the value type is a winrt::event_revoker it will
                                // revoke in its destructor so simply erasing the value will
                                // fix the map and unregister the event.
                                // removeEventListener silently ignores requests to unregister
                                // event handlers that aren't registered.
                                m_eventRegistrationUpdated.erase(dispParams->rgvarg[0].pdispVal);
                                hr = S_OK;
                            }
                            else
                            {
                                // RemoveEventListener silently ignores unregistering events that don't exist.
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = DISP_E_BADVARTYPE;
                        }
                    }
                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 4:
                {
                    // Invoke for Status
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserWatcher>();
                            auto resultAsWinRT = innerObject.Status();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_UserChangedEventArgs::Class_Windows_System_UserChangedEventArgs(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_UserChangedEventArgs_dispatchProperties[] =
{
    L"changedPropertyKinds",
    L"user"
};
DispatchProperties Class_Windows_System_UserChangedEventArgs::s_dispatchProperties = s_Class_Windows_System_UserChangedEventArgs_dispatchProperties;
const DISPID Class_Windows_System_UserChangedEventArgs::s_dispatchIds[2] =
{
    3,
    2
};

HRESULT Class_Windows_System_UserChangedEventArgs::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_UserChangedEventArgs_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_UserChangedEventArgs::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_UserChangedEventArgs::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 2))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_UserChangedEventArgs::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_UserChangedEventArgs::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for User
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserChangedEventArgs>();
                            auto resultAsWinRT = innerObject.User();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for ChangedPropertyKinds
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserChangedEventArgs>();
                            auto resultAsWinRT = innerObject.ChangedPropertyKinds();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_UserAuthenticationStatusChangingEventArgs::Class_Windows_System_UserAuthenticationStatusChangingEventArgs(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_UserAuthenticationStatusChangingEventArgs_dispatchProperties[] =
{
    L"currentStatus",
    L"getDeferral",
    L"newStatus",
    L"user"
};
DispatchProperties Class_Windows_System_UserAuthenticationStatusChangingEventArgs::s_dispatchProperties = s_Class_Windows_System_UserAuthenticationStatusChangingEventArgs_dispatchProperties;
const DISPID Class_Windows_System_UserAuthenticationStatusChangingEventArgs::s_dispatchIds[4] =
{
    3,
    1,
    4,
    5
};

HRESULT Class_Windows_System_UserAuthenticationStatusChangingEventArgs::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_UserAuthenticationStatusChangingEventArgs_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangingEventArgs::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangingEventArgs::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangingEventArgs::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangingEventArgs::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetDeferral
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.GetDeferral(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 3:
                {
                    // Invoke for CurrentStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.CurrentStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for NewStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.NewStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for User
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.User();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserChangedEventArgs::Class_Windows_System_IUserChangedEventArgs(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserChangedEventArgs_dispatchProperties[] =
{
    L"user"
};
DispatchProperties Class_Windows_System_IUserChangedEventArgs::s_dispatchProperties = s_Class_Windows_System_IUserChangedEventArgs_dispatchProperties;
const DISPID Class_Windows_System_IUserChangedEventArgs::s_dispatchIds[1] =
{
    2
};

HRESULT Class_Windows_System_IUserChangedEventArgs::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserChangedEventArgs_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserChangedEventArgs::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserChangedEventArgs::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserChangedEventArgs::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserChangedEventArgs::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for User
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserChangedEventArgs>();
                            auto resultAsWinRT = innerObject.User();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserChangedEventArgs2::Class_Windows_System_IUserChangedEventArgs2(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserChangedEventArgs2_dispatchProperties[] =
{
    L"changedPropertyKinds"
};
DispatchProperties Class_Windows_System_IUserChangedEventArgs2::s_dispatchProperties = s_Class_Windows_System_IUserChangedEventArgs2_dispatchProperties;
const DISPID Class_Windows_System_IUserChangedEventArgs2::s_dispatchIds[1] =
{
    2
};

HRESULT Class_Windows_System_IUserChangedEventArgs2::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserChangedEventArgs2_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserChangedEventArgs2::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserChangedEventArgs2::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserChangedEventArgs2::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserChangedEventArgs2::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 2:
                {
                    // Invoke for ChangedPropertyKinds
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserChangedEventArgs2>();
                            auto resultAsWinRT = innerObject.ChangedPropertyKinds();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::Class_Windows_System_IUserAuthenticationStatusChangingEventArgs(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserAuthenticationStatusChangingEventArgs_dispatchProperties[] =
{
    L"currentStatus",
    L"getDeferral",
    L"newStatus",
    L"user"
};
DispatchProperties Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::s_dispatchProperties = s_Class_Windows_System_IUserAuthenticationStatusChangingEventArgs_dispatchProperties;
const DISPID Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::s_dispatchIds[4] =
{
    3,
    1,
    4,
    5
};

HRESULT Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserAuthenticationStatusChangingEventArgs_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangingEventArgs::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method GetDeferral
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.GetDeferral(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {
                case 3:
                {
                    // Invoke for CurrentStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.CurrentStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for NewStatus
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.NewStatus();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }
                case 5:
                {
                    // Invoke for User
                    if (flags == DISPATCH_PROPERTYGET)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangingEventArgs>();
                            auto resultAsWinRT = innerObject.User();

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_UserAuthenticationStatusChangeDeferral::Class_Windows_System_UserAuthenticationStatusChangeDeferral(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_UserAuthenticationStatusChangeDeferral_dispatchProperties[] =
{
    L"complete"
};
DispatchProperties Class_Windows_System_UserAuthenticationStatusChangeDeferral::s_dispatchProperties = s_Class_Windows_System_UserAuthenticationStatusChangeDeferral_dispatchProperties;
const DISPID Class_Windows_System_UserAuthenticationStatusChangeDeferral::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_System_UserAuthenticationStatusChangeDeferral::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_UserAuthenticationStatusChangeDeferral_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangeDeferral::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangeDeferral::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangeDeferral::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_UserAuthenticationStatusChangeDeferral::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Complete
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangeDeferral>();
                    innerObject.Complete(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}
#include <algorithm>
#include <array>
#include <windows.h>

namespace wv2winrt_impl
{
Class_Windows_System_IUserAuthenticationStatusChangeDeferral::Class_Windows_System_IUserAuthenticationStatusChangeDeferral(::IInspectable* innerObject, const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
    m_innerObject.copy_from(innerObject);
}

const static wchar_t* const s_Class_Windows_System_IUserAuthenticationStatusChangeDeferral_dispatchProperties[] =
{
    L"complete"
};
DispatchProperties Class_Windows_System_IUserAuthenticationStatusChangeDeferral::s_dispatchProperties = s_Class_Windows_System_IUserAuthenticationStatusChangeDeferral_dispatchProperties;
const DISPID Class_Windows_System_IUserAuthenticationStatusChangeDeferral::s_dispatchIds[1] =
{
    1
};

HRESULT Class_Windows_System_IUserAuthenticationStatusChangeDeferral::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Class_Windows_System_IUserAuthenticationStatusChangeDeferral_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangeDeferral::GetPropertiesPrecacheability(BOOL**, size_t*)
{
    return E_NOTIMPL;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangeDeferral::GetIDsOfNames(REFIID riid,
                                             LPOLESTR* names,
                                             unsigned int namesCount,
                                             LCID localeId,
                                             DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 1))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangeDeferral::GetInnerObject(IUnknown** object)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    if (m_innerObject != nullptr)
    {
        hr = S_OK;
        *object = m_innerObject.as<IUnknown>().detach();
    }

    return hr;
}

HRESULT Class_Windows_System_IUserAuthenticationStatusChangeDeferral::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for method Complete
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto innerObject = m_innerObject.as<winrt::Windows::System::IUserAuthenticationStatusChangeDeferral>();
                    innerObject.Complete(
                    );

                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}

namespace wv2winrt_impl
{
Static_Class_Windows_System_User::Static_Class_Windows_System_User(const winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter& dispatchAdapter)
    : m_dispatchAdapter(dispatchAdapter)
{
}

const static wchar_t* const s_Static_Class_Windows_System_User_dispatchProperties[] =
{
    L"createWatcher",
    L"findAllAsync",
    L"getDefault",
    L"getFromId"
};
DispatchProperties Static_Class_Windows_System_User::s_dispatchProperties = s_Static_Class_Windows_System_User_dispatchProperties;

const DISPID Static_Class_Windows_System_User::s_dispatchIds[4] =
{
    1,
    2,
    4,
    3
};

HRESULT Static_Class_Windows_System_User::GetPropertyNames(wchar_t*** namesOut, size_t* namesLengthOut)
{
    *namesLengthOut = ARRAYSIZE(s_Static_Class_Windows_System_User_dispatchProperties);
    *namesOut = const_cast<wchar_t **>(s_dispatchProperties);
    return S_OK;
}

HRESULT Static_Class_Windows_System_User::GetIDsOfNames(
    REFIID riid,
    LPOLESTR* names,
    unsigned int namesCount,
    LCID localeId,
    DISPID* dispId)
{
    HRESULT hr = DispatchBase::GetIDsOfNames(
        riid, names, namesCount, localeId, dispId);
    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        size_t idx;
        if (LookupProperty(s_dispatchProperties, names[0], idx, 4))
        {
            *dispId = s_dispatchIds[idx];
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT Static_Class_Windows_System_User::Invoke(
    DISPID dispId,
    REFIID riid,
    LCID localeId,
    WORD flags,
    DISPPARAMS* dispParams,
    VARIANT* result,
    EXCEPINFO* excepInfo,
    UINT* argErr)
{
    HRESULT hr = DispatchBase::Invoke(dispId,
                                      riid,
                                      localeId,
                                      flags,
                                      dispParams,
                                      result,
                                      excepInfo,
                                      argErr);

    if (SUCCEEDED(hr))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        if (flags == DISPATCH_METHOD || flags == 0)
        {
#ifdef _MSC_VER
// A class may have no methods and in that case this switch statement will
// have only a default case and so will invoke warning 4065. This is fine and
// so we disable the warning.
// <https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warnings-c4000-through-c4199>
#pragma warning( push )
#pragma warning( disable: 4065 )
#endif
            switch (dispId)
            {
                case 1:
                {
                    // Invoke for CreateWatcher
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::System::User::CreateWatcher(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 2:
                {
                    // Invoke for FindAllAsync
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto asyncResultAsWinRT = winrt::Windows::System::User::FindAllAsync(
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto asyncResultAsWinRT = winrt::Windows::System::User::FindAllAsync(
                                Converter<VARIANT, winrt::Windows::System::UserType>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else if (2 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto asyncResultAsWinRT = winrt::Windows::System::User::FindAllAsync(
                                Converter<VARIANT, winrt::Windows::System::UserType>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 0 - 1])
                                ,
                                Converter<VARIANT, winrt::Windows::System::UserAuthenticationStatus>(m_dispatchAdapter).Convert(dispParams->rgvarg[2 - 1 - 1])
                    );

                            if (asyncResultAsWinRT)
                            {
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncResult> asyncResultAsCOM;
                                wv2winrt_impl::CreateDispatchAsyncResult(asyncResultAsCOM.put());
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncFinishedHandler> asyncCompletedHandlerAsCOM;
                                asyncResultAsCOM.as(asyncCompletedHandlerAsCOM);
                                auto dispatchAdapter = m_dispatchAdapter;
                                winrt::com_ptr<ICoreWebView2PrivateDispatchAsyncInfo> asyncInfoAsCOM;
                                asyncResultAsCOM.as(asyncInfoAsCOM);
                                asyncInfoAsCOM->SetAsyncInfo(asyncResultAsWinRT);

                                asyncResultAsWinRT.Completed(
                                    [asyncCompletedHandlerAsCOM, dispatchAdapter](
                                        const auto& asyncInfo,
                                        winrt::Windows::Foundation::AsyncStatus const& asyncStatus)
                                    {
                                        if (asyncStatus == winrt::Windows::Foundation::AsyncStatus::Completed)
                                        {
                                            UniqueVariant resultAsVariant;
                                            auto resultAsWinRT = asyncInfo.GetResults();
                                            resultAsVariant.reset(Converter<decltype(resultAsWinRT), VARIANT>(
                                                    dispatchAdapter)
                                                    .Convert(resultAsWinRT));
                                            asyncCompletedHandlerAsCOM->Invoke(
                                                asyncInfo.ErrorCode().value,
                                                resultAsVariant.addressof());
                                        }
                                        else
                                        {
                                            asyncCompletedHandlerAsCOM->Invoke(asyncInfo.ErrorCode().value, nullptr);
                                        }
                                    });
                                UniqueVariant resultAsVariant;
                                resultAsVariant.vt = VT_UNKNOWN;
                                asyncResultAsCOM.as<IUnknown>().copy_to(&resultAsVariant.punkVal);
                                *result = resultAsVariant.release();
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 3:
                {
                    // Invoke for GetFromId
                    if (1 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::System::User::GetFromId(
                                Converter<VARIANT, winrt::hstring>(m_dispatchAdapter).Convert(dispParams->rgvarg[1 - 0 - 1])
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }
                case 4:
                {
                    // Invoke for GetDefault
                    if (0 == dispParams->cArgs)
                    {
                        hr = S_OK;
                        try
                        {
                            auto resultAsWinRT = winrt::Windows::System::User::GetDefault(
                    );

                            *result = Converter<decltype(resultAsWinRT), VARIANT>(m_dispatchAdapter).Convert(resultAsWinRT);
                        }
                        catch (winrt::hresult_error)
                        {
                            hr = winrt::to_hresult();
                        }
                        catch (...)
                        {
                            hr = E_UNEXPECTED;
                        }
                    }

                    else
                    {
                        hr = DISP_E_BADPARAMCOUNT;
                    }
                    break;
                }

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#ifdef _MSC_VER
#pragma warning( pop )
#endif
        }
        else if (flags == DISPATCH_PROPERTYGET || flags == DISPATCH_PROPERTYPUT)
        {
#pragma warning( push )
#pragma warning( disable: 4065 )
            switch (dispId)
            {

                default:
                    hr = DISP_E_MEMBERNOTFOUND;
                    break;
            }
#pragma warning( pop )
        }
    }
    return hr;
}

}


